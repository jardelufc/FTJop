
\section{A Profile for Safety Critical Java}
\label{sec:scjava}

The proposed profile is an refinement of the profile described in
Section~\label{sec:rtprof}. Further development of applications on
JOP shall be based on this profile and the current applications
(e.g.\ \"OBB bg and Lift) should be migrated to this profile.

\emph{TODO: update with our ISROC 2007 paper and remove Jan's text.}

\section{Safety Critical Java}

Puschner and Wellings were the first to consider the concerns of
safety- and mission-critical systems in the context of the RTSJ for
Java~\cite{Pusch01}. Their proposal adopts the approach pioneered by
the Ravenscar tasking profile for Ada~\cite{697453} which defined a
strict subset of the Ada language for high-integrity systems.  This
work was later refined by Schoeberl et al.~\cite{jop:scjava}.

In this paper we focus on the Safety Critical Java (SCJ)
specification, a new standard for safety critical applications which
is being drafted by the JSR 302 expert group.

%%%
We should note that JSR 302 has not been finalized, thus our
presentation gives an overview of work in progress. Furthemore, our
proposal of real-time garbage collection to SCJ is an extension of
the proposed standard.


This draft JSR 302 standard, like previous work, defines a strict
subset of the RTSJ which is intended to provide a programming model
suited to a large class of safety critical applications. Restricting
the features of the RTSJ is intended to make programs more amenable
to worst case analysis and manual or automatic validation. The SCJ
is structured in three increasingly expressive levels: Level 0
restricts applications to a single threaded cyclic executive, level
1 assumes a single ``mission'' with a static thread assignment, and
level 2 is a multi-mission model with dynamic thread creation. This
paper focuses on level 1 which is expected to cover a large number
of existing SC applications. It should be noted that while all
levels are designed to run on a vanilla RTSJ VM, it is expected that
vendors will provided implementations that are optimized for the
particular features of each level.


\begin{figure}[t!]
{\small
\begin{verbatim}
package javax.safetycritical;

public abstract class RealtimeThread {

    protected RealtimeThread(RelativeTime period,
        RelativeTime deadline,
        RelativeTime offset, int memSize)

    protected RealtimeThread(String event,
        RelativeTime minInterval,
        RelativeTime deadline, int memSize)

    abstract protected boolean run();

    protected boolean cleanup() {
        return true;
    }
}

public abstract class PeriodicThread
        extends RealtimeThread {

    public PeriodicThread(RelativeTime period,
        RelativeTime deadline,
        RelativeTime offset, int memSize)

    public PeriodicThread(RelativeTime period)
}
\end{verbatim} }
\caption{Periodic thread definition for SCJ}\label{lst:scjdef}
\end{figure}

\subsection{SCJ Level 1}

Level 1 of the SCJ requires that all threads be defined during an
initial \emph{initialization} phase. This phase is run only once at
virtual machine startup. The second phase, called the \emph{mission}
phase, begins only when all threads have been started. This phase
runs until virtual machine shutdown. Level 1 supports only two kinds
of schedulable objects: periodic threads and sporadic events. The
latter can be generated by either hardware or software. This
restrictions keeps the schedulability analysis simple. In SCJ
priority ceiling emulation is the default monitor control policy.
The default ceiling is top priority.

The Java \code{wait} and \code{notify} primitives are not allowed in
SCJ level 0 and 1. This further simplifies analysis. The consequence
is that a thread context switch can only occur if a higher priority
thread is released or if the current running thread yields (in the
case of SCJ by returning from the \code{run()} method).

In the RTSJ, periodic tasks are expressed by unbounded loops with,
at some point, a call to the \code{waitForNextPeriod()} (or
\code{wFNP()} for short) method of class \code{RealtimeThread}. This
has the effect of yielding control to the scheduler which will only
wake the thread when its next period starts or shortly thereafter.
In SCJ, as a simplification, periodic logic is encapsulated in a
\code{run()} method which is invoked at the start of every period of
a given schedulable object. When the thread returns from
\code{run()} it is blocked until the next period.

Figure~\ref{lst:scjdef} shows part of the definition of the SCJ
thread classes from \cite{jop:scjava}\footnote{These are similar to
the draft JSR
  302 class definitions, but as the specification is still in the process of
  being finalized we choose to use the classes available in the
  infrastructure we use for our implementation.}. Figure~\ref{lst:per} shows
the code for a periodic thread. This class has only one \code{run()}
method which performs a periodic computation.

The loop construct with \code{wFNP()} is not used. The main
intention to avoid the loop construct, with the possibility to split
application logic into \emph{mini} phases, is simplification of the
WCET analysis. Only a single method has to be analyzed per thread
instead of all possible control flow path between \code{wFNP()}
invocations.

\begin{figure}[!t]
{\small
\begin{verbatim}
new PeriodicThread(
    new RelativeTime(...)) {

        protected boolean run() {
            doPeriodicWork();
            return true;
        }
};
\end{verbatim} }
    \caption{A periodic application thread in SCJ}
    \label{lst:per}
\end{figure}

\begin{figure}[!t]
{\small
\begin{verbatim}
    public void run() {

        State local = new State();
        doSomeInit();
        local.setA();
        waitForNextPeriod();

        for (;;) {
            while (!switchToB()) {
                doModeAwork();
                waitForNextPeriod();
            }
            local.setB();
            while (!switchToA()) {
                doModeBWork();
                waitForNextPeriod();
            }
            local.setA();
        }
    }
\end{verbatim} }
    \caption{Possible logic for a periodic thread in the RTSJ}\label{lst:rtsj:per}
\end{figure}


We contrast the SCJ threading with Figure~\ref{lst:rtsj:per} where a
periodic RTSJ thread is shown. Suspension of the thread to wait for
the next period is performed by an explicit invocation of
\code{wFNP()}. The coding style in this example makes analysis of
the code more difficult than necessary. First the initialization
logic is mixed with the code of the mission phase, this means that a
static analysis may be required to discover the boundary between the
startup code and the periodic behavior. The code also performs mode
switches with calls to \code{wFNP()} embedded in the logic. This
makes the worst case analysis more complex as calls to \code{wFNP()}
may occur anywhere and require deep understanding of feasible
control flow paths.  Another issue, which does not affect
correctness, is the fact that object references can be preserved in
local variables across calls to \code{wFNP()}. As we will see later
this has implications for the GC.
