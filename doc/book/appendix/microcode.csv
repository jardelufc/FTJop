pop;Pop the top operand stack value;{00000000};B\to A \\ stack[sp] \to B \\sp-1 \to sp;pop;Pop the top value from the operand stack.
and;Boolean AND \code{int};{00000001};A \wedge B\to A \\ stack[sp] \to B \\sp-1 \to sp;iand;Build the bitwise AND (conjunction) of the two top elements of the stack and push back the result onto the operand stack.
or;Boolean OR \code{int};{00000010};A \vee B\to A \\ stack[sp] \to B \\sp-1 \to sp;ior;Build the bitwise inclusive OR (disjunction) of the two top elements of the stack and push back the result onto the operand stack.
xor;Boolean XOR \code{int};{00000011};A \not\equiv B\to A \\ stack[sp] \to B \\sp-1 \to sp;ixor;Build the bitwise exclusive OR (negation of equivalence) of the two top elements of the stack and push back the result onto the operand stack.
add;Add \code{int};{00000100};A+B\to A \\ stack[sp] \to B \\sp-1 \to sp;iadd;Add the two top elements from the stack and push back the result onto the operand stack.
sub;Subtract \code{int};{00000101};A-B\to A \\ stack[sp] \to B \\sp-1 \to sp;isub;Subtract the two top elements from the stack and push back the result onto the operand stack.
stmul;Multiply \code{int};{00000110};A \to mula \\ B \to mulb \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the stack is stored as first operand for the multiplier. The value one below the top of stack is stored as second operand for the multiplier. This operation starts the multiplier. The result is read with the \code{ldmul} instruction.
stmwa;Store memory write address;{00000111};A \to memwra \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the stack is stored as write address in the memory subsystem for a following \code{stmwd}.
stmra;Store memory read address;{00001000};A \to memrda \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the stack is stored as read address in the memory subsystem. This operation starts the concurrent memory read. The processor can continue with other operations. When the datum is needed a \code{wait} instruction stalls the processor till the read access is finished. The value is read with \code{ldmrd}.
stmwd;Store memory write data;{00001001};A \to memwrd \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the stack is stored as write data in the memory subsystem. This operation starts the concurrent memory write The processor can continue with other operations. The \code{wait} instruction stalls the processor till the write access is finished.
stald;Start array load;{00001010};A \to memidx \\ B\to A \\ B\to memptr \\ stack[sp] \to B \\sp-1 \to sp;xaload;The top value from the stack is stored as array index, the next as reference in the memory subsystem. This operation starts the concurrent array load. The processor can continue with other operations. The \code{wait} instruction stalls the processor till the read access is finished. A null pointer or out of bounds exception is generated by the memory subsystem and thrown at the next bytecode fetch.
stast;Start array store;{00001011};A \to memval\\ B\to A \\ stack[sp] \to B \\sp-1 \to sp\\ next cycle \\ A \to memidx \\ B\to A \\ B\to memptr \\ stack[sp] \to B \\sp-1 \to sp;xastore;In the first cycle the top value from the stack is stored as value into the memory subsystem. A microcode \code{pop} has to follow. In the second cycle the top value from the stack is stored as array index, the next as reference in the memory subsystem. This operation starts the concurrent array store. The processor can continue with other operations. The \code{wait} instruction stalls the processor till the write access is finished. A null pointer or out of bounds exception is generated by the memory subsystem and thrown at the next bytecode fetch.
stgf;Start getfield;{00001100};A \to memidx \\ B\to A \\ B\to memptr \\ stack[sp] \to B \\sp-1 \to sp;getfield;The top value from the stack is stored as field index, the next as reference in the memory subsystem. This operation starts the concurrent getfield. The processor can continue with other operations. The \code{wait} instruction stalls the processor till the read access is finished. A null pointer exception is generated by the memory subsystem and thrown at the next bytecode fetch.
stpf;Start putfield;{00001101};A \to memval\\ B\to A \\ stack[sp] \to B \\sp-1 \to sp\\ next cycle \\ A \to memidx \\ B\to A \\ B\to memptr \\ stack[sp] \to B \\sp-1 \to sp;putfield;In the first cycle the top value from the stack is stored as value into the memory subsystem. A microcode \code{pop} has to follow. In the second cycle the top value from the stack is stored as field index, the next as reference in the memory subsystem. This operation starts the concurrent putfield. The processor can continue with other operations. The \code{wait} instruction stalls the processor till the write access is finished. A null pointer exception is generated by the memory subsystem and thrown at the next bytecode fetch.
stcp;Start copy step;{00001110};A \to memidx \\ B\to memsrc \\ stack[sp] \to B \\sp-1 \to sp\\ next cycle \\ B \to memdest \\stack[sp] \to B \\ sp-1 \to sp;--;In the first cycle the top value from the stack is stored as index, the next as reference to which the index must be added for the source position. A microcode \code{pop} has to follow. In the second cycle the reference for the destination is stored in the memory subsystem. This operation starts the concurrent copy step. The processor can continue with other operations. The \code{wait} instruction stalls the processor till the write access is finished. The memory subsystem translates addresses such that copying of memory areas may be interrupted without affecting the consistency of data. Copying has to be done with increasing indices for correct operation. A negative index stops the address translation.
stbcrd;Start bytecode read;{00001111};A \to membcr \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the stack is stored as address and length of a method in the memory subsystem. This operation starts the memory transfer from the main memory to the bytecode cache (DMA). The processor can continue with other operations. The \code{wait} instruction stalls the processor till the transfer has finished. No other memory accesses are allowed during the bytecode read.
st$<$n$>$;Store 32-bit word into local variable;{000100nn};A \to stack[vp+n] \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;astore_$<$n$>$, istore_$<$n$>$, fstore_$<$n$>$;The value on the top of the operand stack is popped and stored in the local variable at position $n$.
st;Store 32-bit word into local variable;{00010100};A \to stack[vp+opd] \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;astore, istore, fstore;The value on the top of the operand stack is popped and stored in the local variable at position $opd$. $opd$ is taken from the bytecode instruction stream.
stmi;Store in local memory indirect;{00010101};A \to stack[ar] \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the operand stack is stored in the local memory (stack) at position ar.
stvp;Store variable pointer;{00011000};A \to vp \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The value on the top of the operand stack is popped and stored in the variable pointer (\code{vp}).
stjpc;Store Java program counter;{00011001};A \to jpc \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The value on the top of the operand stack is popped and stored in the Java program counter (\code{jpc}).
star;Store adress register;{00011010};A \to ar \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The value on the top of the operand stack is popped and stored in the address register (\code{ar}). Due to a pipeline delay the register is valid on cycle later for usage by \code{ldmi} and \code{stmi}.
stsp;Store stack pointer;{00011011};A \to sp \\ B\to A \\ stack[sp] \to B;--;The value on the top of the operand stack is popped and stored in the stack pointer (\code{sp}).
ushr;Logical shift rigth \code{int};{00011100};B >>> A \to A \\ stack[sp] \to B \\sp-1 \to sp;iushr;The values are popped from the operand stack. An \code{int} result is calculated by shifting the TOS-1 value rigth by $s$ position, with zero extension, where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack.
shl;Shift left \code{int};{00011101};B << A \to A \\ stack[sp] \to B \\sp-1 \to sp;ishl;The values are popped from the operand stack. An \code{int} result is calculated by shifting the TOS-1 value left by $s$ position, where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack.
shr;Arithmetic shift rigth \code{int};{00011110};B >> A \to A \\ stack[sp] \to B \\sp-1 \to sp;ishr;The values are popped from the operand stack. An \code{int} result is calculated by shifting the TOS-1 value rigth by $s$ position, with sign extension, where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack.
stm;Store in local memory;{001nnnnn};A \to stack[n] \\ B\to A \\ stack[sp] \to B \\sp-1 \to sp;--;The top value from the operand stack is stored in the local memory (stack) at position n. These 32 memory destinations represent microcode local variables.
bz;Branch if value is zero;{010nnnnn};\mbox{if}\:\: A = 0 \:\: \mbox{then} \:\: pc+offtbl[n]+2 \to pc \\ B \to A \\ stack[sp] \to B \\sp-1 \to sp;--;If the top value from the operand stack is zero a microcode branch is taken. The value is popped from the operand stack. Due to a pipeline delay, the zero flag is delayed one cycle, i.e.\ the value from the last but one instruction is taken. The branch is followed by two branch delay slots. The branch offset is taken from the table $offtbl$ indexed by $n$.
bnz;Branch if value is not zero;{011nnnnn};\mbox{if}\:\: A \not= 0 \:\: \mbox{then} \:\: pc+offtbl[n]+2 \to pc \\ B \to A \\ stack[sp] \to B \\sp-1 \to sp;--;If the top value from the operand stack is not zero a microcode branch is taken. The value is popped from the operand stack. Due to a pipeline delay, the zero flag is delayed one cycle, i.e.\ the value from the last but one instruction is taken. The branch is followed by two branch delay slots. The branch offset is taken from the table $offtbl$ indexed by $n$.
nop;Do nothing;{10000000};-;nop;The famous no operation instruction.
wait;Wait for memory completion;{10000001};-;--;This instruction stalls the processor until a pending memory instruction (\code{stmra}, \code{stmwd} or \code{stbcrd}) has completed. Two consecutive \code{wait} instructions are necessary for a correct stall of the decode and execute stage.
jbr;Conditional bytecode branch and goto;{10000010};-;ifnull, ifnonnull, ifeq, ifne, iflt, ifge, ifgt, ifle, if_acmpeq, if_acmpne, if_icmpeq, if_icmpne, if_icmplt, if_icmpge, if_icmpgt, if_icmple, goto;Execute a bytecode branch or goto. The branch condition and offset are calculated in the bytecode fetch unit. Arguments must be removed with \code{pop} instructions in the following microcode instructions.
ldm;Load from local memory;{101nnnnn};stack[n] \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The value from the local memory (stack) at position $n$ is pushed onto the operand stack. These 32 memory destinations represent microcode local variables.
ldi;Load from local memory;{110nnnnn};stack[n+32] \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The value from the local memory (stack) at position $n+32$ is pushed onto the operand stack. These 32 memory destinations represent microcode constants.
ldmrd;Load memory read data;{11100010};memrdd \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The value from the memory system after a memory read is pushed onto the operand stack. This operation is usually preceded by two \code{wait} instructions.
ldmul;Load multiplier result;{11100101};mulr \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;(imul);The result of the multiplier is pushed onto the operand stack.
ldbcstart;Load method start;{11100111};bcstart \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The method start address in the method cache is pushed onto the operand stack.
ld$<$n$>$;Load 32-bit word from local variable;{111010nn};stack[vp+n] \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;aload_$<$n$>$, iload_$<$n$>$, fload_$<$n$>$;The local variable at position $n$ is pushed onto the operand stack.
ld;Load 32-bit word from local variable;{11101100};stack[vp+opd] \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;aload, iload, fload;The local variable at position $opd$ is pushed onto the operand stack. $opd$ is taken from the bytecode instruction stream.
ldmi;Load from local memory indirect;{11101101};stack[ar] \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The value from the local memory (stack) at position ar is pushed onto the operand stack.
ldsp;Load stack pointer;{11110000};sp \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The stack pointer is pushed onto the operand stack.
ldvp;Load variable pointer;{11110001};vp \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The variable pointer is pushed onto the operand stack.
ldjpc;Load Java program counter;{11110010};jpc \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;The Java program counter is pushed onto the operand stack.
ld_opd_8u;Load 8-bit bytecode operand unsigned;{11110100};opd \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;A single byte from the bytecode stream is pushed as \code{int} onto the operand stack.
ld_opd_8s;Load 8-bit bytecode operand signed;{11110101};opd \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;(bipush);A single byte from the bytecode stream is sign-extended to an \code{int} and pushed onto the operand stack.
ld_opd_16u;Load 16-bit bytecode operand unsigned;{11110110};opd_{16} \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;--;A 16-bit word from the bytecode stream is pushed as \code{int} onto the operand stack.
ld_opd_16s;Load 16-bit bytecode operand signed;{11110111};opd_{16} \to A \\ A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;(sipush);A 16-bit word from the bytecode stream is sign-extended to an \code{int} and pushed onto the operand stack.
dup;Duplicate the top operand stack value;{11111000};A \to B \\ B \to stack[sp+1] \\sp+1 \to sp;dup;Duplicate the top value on the operand stack and push it onto the operand stack.
