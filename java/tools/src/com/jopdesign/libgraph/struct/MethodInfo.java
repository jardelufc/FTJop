/*
 * Copyright (c) 2007,2008, Stefan Hepp
 *
 * This file is part of JOPtimizer.
 *
 * JOPtimizer is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * JOPtimizer is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.jopdesign.libgraph.struct;

import com.jopdesign.libgraph.struct.type.MethodSignature;
import com.jopdesign.libgraph.struct.type.TypeHelper;
import org.apache.log4j.Logger;

import java.util.HashSet;
import java.util.Set;

/**
 * @author Stefan Hepp, e0026640@student.tuwien.ac.at
 */
public abstract class MethodInfo implements ClassElement {

    private boolean initialzed;

    private ClassInfo classInfo;
    private MethodSignature methodSignature;

    private MethodInfo superMethod;
    private Set overwriters;

    private static Logger logger = Logger.getLogger(MethodInfo.class);

    public MethodInfo(ClassInfo classInfo) {
        this.classInfo = classInfo;
        this.overwriters = new HashSet();
        methodSignature = null;
        initialzed = false;
    }

    public AppStruct getAppStruct() {
        return getClassInfo().getAppStruct();
    }

    public boolean isInitialized() {
        return initialzed;
    }

    public MethodSignature getMethodSignature() throws TypeException {
        if ( methodSignature == null ) {
            methodSignature = TypeHelper.parseSignature(getAppStruct(), getName(), getSignature());
        }
        return methodSignature;
    }

    public abstract boolean isSynchronized();

    public abstract boolean isInterface();

    public abstract boolean isNative();

    /**
     * Check if this method has code or not.
     * @return true, if this method has no code assigned.
     */
    public abstract boolean isAbstract();

    public void reload() throws TypeException {
        
        // check if this method overwrites another method.
        superMethod = classInfo.getInheritedMethodInfo(getMethodSignature().getFullName(), true, true);
        if ( superMethod != null ) {
            superMethod.addOverwriter(this);

            if ( logger.isDebugEnabled() ) {
                logger.debug("Found super method for {"+getFQMethodName()+"} in {"+
                        superMethod.getClassInfo().getClassName()+"}.");
            }
        }

    }

    public ClassInfo getClassInfo() {
        return classInfo;
    }

    /**
     * get the method signature with the class name prepended.
     * @return the classname and the method name and signature.
     */
    public String getFQMethodName() {
        return createFQMethodName(classInfo.getClassName(), getName(), getSignature());
    }

    public boolean isSameMethod(MethodInfo methodInfo) {
        return getFQMethodName().equals(methodInfo.getFQMethodName());
    }

    /**
     * convenience helper method to split a fully qualified method name as generated by
     * {@link #getFQMethodName()} into class and method signature and search the given method.
     *
     * @param appStruct the appStruct container which contains all classinfos.
     * @param methodName the full methodname with classname#signature.
     * @return the methodinfo of the given class or null if not found.
     */
    public static MethodInfo parseFQMethodName(AppStruct appStruct, String methodName) {
        int hash = methodName.indexOf("#");
        if ( hash == -1 ) {
            if (logger.isDebugEnabled()) {
                logger.debug("Invalid methodname {"+methodName+"} in parseFQMethodName.");
            }
            return null;
        }

        ClassInfo classInfo = appStruct.getClassInfo(methodName.substring(0,hash));
        if ( classInfo == null ) {
            return null;
        }

        return classInfo.getMethodInfo(methodName.substring(hash+1));
    }

    public static String createFQMethodName(String classname, String methodname, String signature) {
        StringBuffer out = new StringBuffer();
        out.append(classname);
        out.append("#");
        out.append(methodname);
        out.append(signature);
        return out.toString();
    }

    /**
     * get the method code class for this method, or null if this method has no body.
     * @return the method code or null if this has no code.
     */
    public abstract MethodCode getMethodCode();

    /**
     * check if this method overwrites a super method.
     * This is false if any method is private or static.
     *
     * @return true if this method overwrites a method in any super class.
     */
    public boolean hasSuperMethod() {
        return superMethod != null;
    }

    /**
     * check if there is any known subclass which overwrites this method.
     * All methodInfos must have been reloaded and all classes must be known for this to work correctly.
     * @return true if any method overwrites this method.
     */
    public boolean isOverwritten() {
        return overwriters.size() != 0;
    }

    /**
     * @return true if this method overwrites another method or is overwritten.
     */
    public boolean isVirtual() {
       return hasSuperMethod() || isOverwritten();
    }

    public void addOverwriter(MethodInfo method) {
        overwriters.add(method);
    }

    public int getAccessType() {
        if ( isPublic() ) {
            return ACC_PUBLIC;
        }
        if ( isPrivate() ) {
            return ACC_PRIVATE;
        }
        if ( isProtected() ) {
            return ACC_PROTECTED;
        }
        return ACC_PACKAGE;
    }

    public String getModifierString() {
        StringBuffer out = new StringBuffer();

        if ( isPrivate() ) {
            out.append("private ");
        }
        if ( isProtected() ) {
            out.append("protected ");
        }
        if ( isPublic() ) {
            out.append("public ");
        }
        if ( isSynchronized() ) {
            out.append("synchronized ");
        }
        if ( isNative() ) {
            out.append("native ");
        }
        if ( isInterface() ) {
            out.append("interface ");
        }
        if ( isAbstract() ) {
            out.append("abstract ");
        }
        if ( isStatic() ) {
            out.append("static ");
        }
        if ( isFinal() ) {
            out.append("final ");
        }
        return out.toString();
    }
}
