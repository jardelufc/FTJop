--
--	rom.mif
--
depth = 2048;
width = 10;

content

begin

	[0..1ff] : 080;	-- nop

	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	
	            	--	//
	            	--	//	jvm.asm
	            	--	//
	            	--	//		JVM for JOP3
	            	--	//
	            	--	//	2001-10-24	first version works with Jopa (prime is running)
	            	--	//	2001-10-31	download of bc and ram from serial line (init)
	            	--	//	2001-11-30	change mem acces to direct
	            	--	//	2001-11-31	change to new 'class file' (in memory)
	            	--	//	2001-12-05	new shift loop
	            	--	//				nop !befor! stsp to write correct A value
	            	--	//	2001-12-06	init sp
	            	--	//	2001-12-07	only one jbr, decoding in bcfetch, i2c
	            	--	//				fixed download size
	            	--	//	2001-12-08	changes for ldp, stp instruction coding (8 bit intruction set!)
	            	--	//	2001-12-10	automatic load of bc from external memory if prog.
	            	--	//				does not fit in internal ram
	            	--	//	2002-01-16	imul, idiv, irem, ishr
	            	--	//	2002-02-25	areturn
	            	--	//	2002-03-22	use the booth hw multiplier
	            	--	//	2002-03-24	new JOP instructions shr, shl, ushr
	            	--	//				bc only in extern memory, autoincrement jpc on stbc
	            	--	//	2002-05-10	dup2
	            	--	//	2002-07-24	added special bytecodes jopsys_*
	            	--	//	2002-07-26	sys_rd/wr* from invokestatic removed
	            	--	//				method table => single word const
	            	--	//				call JVM.f() for not implemented byte codes
	            	--	//	2002-07-27	changed len field of method struct to 10 bit
	            	--	//	2002-08-02	changed max_words from 4096 to 8192
	            	--	//	2002-10-08	use JVM.java for new
	            	--	//	2002-10-11	call JVM.java for anewarray
	            	--	//	2002-10-21	added if(non)null, if_acmp
	            	--	//	2002-12-02	use new instruction wait for mem io
	            	--	//	2003-08-13	merged jvm.asm and jvmflash.asm, use C preprocessor
	            	--	//	2003-08-14	changed jbc write to a single 32 bit write (jbc does byte stuff)
	            	--	//	2003-09-11	jopsys function for save and restore of stack in RtThread.schedule()
	            	--	//	2003-09-13	invokespecial still like invokestatic
	            	--	//		Ein offenes Problem! Aber private geht jetzt.
	            	--	//				jjp and jjhp now point to first method
	            	--	//	2003-09-15	cbsf-a-load/store for String class (all array elements are one word)
	            	--	//	2003-10-06	changed max_words from 8192 to 16384, and flash address for Java
	            	--	//				program at 0x80000
	            	--	//	2003-10-23	long load_n, store_n, const_n, l2i added, ldc2_w error corretion
	            	--	//	2003-10-27	invokeinterface
	            	--	//	2004-01-18	ldc_w, pop2; float load, store and return; NOT tested!
	            	--	//	2004-02-07	null pointer check in xaload/xastore, put/getfield and invoke,
	            	--	//				array check, div/rem moved to JVM.java
	            	--	//	2004-02-12	added instruction ld_opd_8u and ld_opd_16u
	            	--	//	2004-03-12	added support for long: lreturn, lload, lstore
	            	--	//	2004-04-06	first two instructions nop because of change in fetch.vhd
	            	--	//				stjpc to nxt pipeline is now one longer (simpler mux for jbc rdaddr)
	            	--	//	2004-05-24	jopsys_invoke to call main() from Startup.boot()
	            	--	//	2004-10-08	single instruction to start mul (with a and b as operands)
	            	--	//	2004-12-11	Enhancements in array access
	            	--	//	2004-09-16	new bc read hardware (jvm_call.inc)
	            	--	//	2005-01-10	changes for bytecode cache (jvm_call.inc)
	            	--	//	2005-02-05	include version number
	            	--	//	2005-02-18	switch for simulation version
	            	--	//	2005-04-27	dup_x2
	            	--	//	2005-05-12	remove nops after mem rd/wr start. the 'io' wr
	            	--	//				generates the first bsy cycle (extension.vhd)
	            	--	//	2005-05-30	wishbone interface (extension.vhd and wb_top.vhd)
	            	--	//	2005-06-13	move newarray to JVM.java
	            	--	//				use indirection (handle) for objects and arrays
	            	--	//	2005-06-14	added multianewarray to JVM.java, version is 
	            	--	//				again without handles
	            	--	//	2005-06-20  use indirection, GC info in class struct
	            	--	//	2005-07-28	fix missing indirection bug in thread stack move (int2ext and ext2int)
	            	--	//	2005-08-13	moved null pointer check in xaload/store to check the handle!
	            	--	//	2005-08-16	new file/download format with a size field in the first word
	            	--	//	2005-08-27	added boot from USB interface (dspio board)
	            	--	//	2005-12-01	IO devices are memory mapped - no more stioa, stiod, ldiod
	            	--	//	2005-12-20	Changed dspio devices (USB) to SimpCon
	            	--	//	2006-01-11	Generate HW exception and invoke JVMHelp.exception()
	            	--	//	2006-01-12	Additional register for int. memory addressing (ar)
	            	--	//				Instructions: star, stmi, ldmi
	            	--	//				removed stioa, stiod, and ldiod
	            	--	//	2006-01-20	add get/put field/static _ref/_long
	            	--	//	2006-01-22	add type info for newarray (for long)
	            	--	//	2006-01-23	use offset instead of cp index for get/putfield
	            	--	//	2006-06-15	enhanced memory/cache interface (less cycles)
	            	--	//	2006-11-04	move mtab pointer and array length to the handle
	            	--	//				little optimization in array load/store
	            	--	//	2006-12-27	add a special bytecode for Peter's single path
	            	--	//				programming
	            	--	//	2006-12-29	2K ROM, laload, lastore enabled again, dup2_x1, dup2_x2
	            	--	//	2006-12-30	add instanceof to invoke JVM.java with constant on TOS
	            	--	//	2007-03-17	new VHDL structure: jopcpu and more records (SimpCon)
	            	--	//	2007-04-14	iaload and iastore in hardware (mem_sc.vhd)
	            	--	//	2007-05-28	putfield_ref and putstatic_ref in JVM.java
	            	--	//  2007-06-01  added multiprocessor startup (CP)
	            	--	//				aastore in JVM.java
	            	--	//	2007-06-17	new instruction jopsys_memcpy, jopsys_cond_move disabled
	            	--	//				speed-up ext2int and int2ext
	            	--	//	2007-08-31	non wrapping stack pointer, version at new address (62)
	            	--	//				start stack at 64 instead of 128
	            	--	//	2007-09-02	new instructions for hardware floating point operation with FPU
	            	--	//	2007-11-21	stack tracing enabled, more space in stack.vhd
	            	--	//				use 33 bit for the comparison (compare bug for diff > 2^31 corrected)
	            	--	//	2007-11-22	update for JOP CMP version (by CP)
	            	--	//	2007-12-03	new interrupt logic
	            	--	//	2008-02-19	WP: field access in HW
	            	--	//	2008-02-20	IO modules after the memory controller (mem_sc) to keep HWO working
	            	--	//	2008-02-24	Changed license to GPL
	            	--	//	2008-03-03	Added scratchpad RAM
	            	--	//	2008-03-04	correct MUX selection
	            	--	//	2008-03-11	Interrupt enable also in bcfetch (bug fix)
	            	--	//	2008-06-11	Remove offtbl adjustment nops
	            	--	//	2008-06-24	moncnt starts with 0, new CMP scheduler
	            	--	//	2008-06-25	WP: bug fix in cache controller
	            	--	//  2008-07-03	WP: Fixed null pointer handling of invokexxx instructions
	            	--	//	2008-07-13	MS: mapping of Native.put/getfield to jopsys version
	            	--	//	2008-08-21	MS: Corrected data out enable in SRAM/Flash interface
	            	--	//	2008-12-10	MS: static field access uses index as address
	            	--	//
	            	--	//		idiv, irem	WRONG when one operand is 0x80000000
	            	--	//			but is now in JVM.java
	            	--	
	            	--	//
	            	--	//	'special' constant for a version number
	            	--	//	gets written in RAM at position 64
	            	--	//	update it when changing .asm, .inc or .vhdl files
	            	--	//
	            	--	version = 20081210
	            	--	
	            	--	//
	            	--	//	start of stack area in the on-chip RAM
	            	--	//
	            	--	stack_init = 64
	            	--	
	            	--	//
	            	--	//	io address are negativ memory addresses
	            	--	//
	            	--	//	CNT=-128
	            	--	//	IO_INT_ENA=-128
	            	--	//	UART status=-112
	            	--	//	UART=-111
	            	--	//	USB status=-96
	            	--	//	USB date=-95
	            	--	//
	            	--	io_cnt = -128
	            	--	io_wd = -125
	            	--	io_int_ena = -128
	            	--	io_status = -112
	            	--	io_uart = -111
	            	--	
	            	--	io_lock = -123
	            	--	io_cpu_id = -122
	            	--	io_signal = -121
	            	--	
	            	--	usb_status = -96
	            	--	usb_data = -95
	            	--	
	            	--	ua_rdrf = 2
	            	--	ua_tdre = 1
	            	--	//
	            	--	//	first vars for start
	            	--	//	keep order! these vars are accessed from Java progs.
	            	--	//
	            	--	 mp ? // pointer to method struct
	            	--	 cp ? // pointer to constants
	            	--	 heap ? // start of heap
	            	--	
	            	--	 jjp ? // pointer to meth. table of Java JVM functions
	            	--	 jjhp ? // pointer to meth. table of Java JVM help functions
	            	--	
	            	--	 moncnt ? // counter for monitor
	            	--	
	            	--	//
	            	--	//	local vars
	            	--	//
	            	--	a ?
	            	--	b ?
	            	--	c ?
	            	--	d ?
	            	--	e ?
	            	--	f ?
	            	--	
	            	--	addr ? // address used for bc load from flash
	            	--	      // only in jvmflash.asm
	            	--	
	            	--	//
	            	--	//	JVM starts here.
	            	--	//
	            	--	//	new fetch does NOT reset address of ROM =>
	            	--	//		it starts with pc+1
	0000 : 080;		--	   nop // this gets never executed
	0001 : 080;		--	   nop // for shure during reset (perhaps two times executed)
	            	--	
	0002 : 0c0;		--	   ldi stack_init
	0003 : 080;		--	   nop // written in adr/read stage!
	0004 : 01b;		--	   stsp // someting strange in stack.vhd A->B !!!
	            	--	
	            	--	
	            	--	// TEST read after write
	            	--	
	            	--	// ldi 1
	            	--	// ldi 2
	            	--	// ldi 3
	            	--	// add
	            	--	// add
	            	--	// pop
	            	--	
	            	--	//////////
	            	--	// test mem interface
	            	--	//
	            	--	//			ldi 15
	            	--	//
	            	--	//			// this sequence takes 6 cycles with ram_cnt=3
	            	--	//			stmra				// start read ext. mem
	            	--	//			wait				// one for fetch
	            	--	//			wait				// one for decode
	            	--	//			ldmrd		 		// read ext. mem
	            	--	//
	            	--	//			ldi	32				// write data
	            	--	//			ldi	16				// write address
	            	--	//
	            	--	//			// this sequence takes 6 cycles with ram_cnt=3
	            	--	//			stmwa				// write ext. mem address
	            	--	//			stmwd				// write ext. mem data
	            	--	//			wait
	            	--	//			wait
	            	--	//
	            	--	//			ldi 7
	            	--	//			stmra				// start read ext. mem
	            	--	//			wait				// one for fetch
	            	--	//			wait				// one for decode
	            	--	//			ldmrd		 		// read ext. mem
	            	--	//
	            	--	//			pop
	            	--	//			pop
	            	--	/////////
	            	--	// test iaload
	            	--	//			ldi	1
	            	--	//			ldi 5
	            	--	//			stald
	            	--	//			pop
	            	--	//			wait
	            	--	//			wait
	            	--	//			ldmrd
	            	--	//			pop
	            	--	//
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop
	            	--	// test iastore
	            	--	//			ldi 1
	            	--	//			ldi 5
	            	--	//			ldi 3
	            	--	//			stast
	            	--	//			pop
	            	--	//			pop
	            	--	//			wait
	            	--	//			wait
	            	--	/////////
	            	--	
	            	--	
	            	--	// Checks whether the cpu_id != 0, waits and jumps then further down to the invoke of the boot!!!
	            	--	
	0005 : 0c1;		--	   ldi io_cpu_id
	0006 : 008;		--	   stmra
	0007 : 081;		--	   wait
	0008 : 081;		--	   wait
	0009 : 0e0;		--	   ldmrd
	000a : 080;		--	   nop
	000b : 040;		--	   bz cpu0_load
	000c : 080;		--	   nop
	000d : 080;		--	   nop
	            	--	
	            	--	cpux_loop:
	000e : 0c2;		--	   ldi io_signal
	000f : 008;		--	   stmra
	0010 : 081;		--	   wait
	0011 : 081;		--	   wait
	0012 : 0e0;		--	   ldmrd
	0013 : 080;		--	   nop
	0014 : 041;		--	   bz cpux_loop
	0015 : 080;		--	   nop
	0016 : 080;		--	   nop
	0017 : 0c2;		--	   ldi io_signal
	0018 : 008;		--	   stmra
	0019 : 081;		--	   wait
	001a : 081;		--	   wait
	001b : 0e0;		--	   ldmrd
	001c : 080;		--	   nop
	001d : 062;		--	   bnz cpux_boot
	001e : 080;		--	   nop
	001f : 080;		--	   nop
	            	--	
	            	--	
	            	--	cpu0_load:
	            	--	
	            	--	//
	            	--	//	Main memory (ram) is loaded by the simulation.
	            	--	//	Just set the heap pointer from the size field.
	            	--	//
	0020 : 0c3;		--	   ldi 0
	0021 : 008;		--	   stmra
	0022 : 081;		--	   wait
	0023 : 081;		--	   wait
	0024 : 0e0;		--	   ldmrd
	0025 : 022;		--	   stm heap
	            	--	// jump to here with cpu_id other than 0
	            	--	
	            	--	cpux_boot:
	            	--	//
	            	--	//	Load mp from the second word in ram.
	            	--	//
	0026 : 0c4;		--	   ldi 1
	0027 : 008;		--	   stmra
	0028 : 081;		--	   wait
	0029 : 081;		--	   wait
	002a : 0e0;		--	   ldmrd
	002b : 020;		--	   stm mp
	            	--	//
	            	--	//	ram is now loaded, heap points to free ram
	            	--	//	load pointer to main struct and invoke
	            	--	//
	002c : 0a0;		--	   ldm mp // pointer to 'special' pointer list
	002d : 0c4;		--	   ldi 1
	002e : 004;		--	   add
	002f : 0f8;		--	   dup
	            	--	
	0030 : 008;		--	   stmra // read jjp
	0031 : 081;		--	   wait
	0032 : 081;		--	   wait
	0033 : 0e0;		--	   ldmrd // read ext. mem
	0034 : 023;		--	   stm jjp
	            	--	
	0035 : 0c4;		--	   ldi 1
	0036 : 004;		--	   add
	0037 : 008;		--	   stmra // read jjhp
	0038 : 081;		--	   wait
	0039 : 081;		--	   wait
	003a : 0e0;		--	   ldmrd // read ext. mem
	003b : 024;		--	   stm jjhp
	            	--	
	003c : 0a0;		--	   ldm mp // pointer to pointer to main meth. struct
	003d : 0c4;		--	   ldi 1
	003e : 080;		--	   nop
	003f : 063;		--	   bnz invoke_main // simulate invokestatic
	0040 : 080;		--	   nop
	0041 : 080;		--	   nop
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	//
	            	--	//	begin of jvm code
	            	--	//
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	
	0042 : 280;		--	nop: nop nxt
	            	--	
	0043 : 2c5;		--	iconst_m1: ldi -1 nxt
	            	--	aconst_null:
	0044 : 2c3;		--	iconst_0: ldi 0 nxt
	0045 : 2c4;		--	iconst_1: ldi 1 nxt
	0046 : 2c6;		--	iconst_2: ldi 2 nxt
	0047 : 2c7;		--	iconst_3: ldi 3 nxt
	0048 : 2c8;		--	iconst_4: ldi 4 nxt
	0049 : 2c9;		--	iconst_5: ldi 5 nxt
	            	--	
	004a : 180;		--	bipush: nop opd
	004b : 2f5;		--	   ld_opd_8s nxt
	            	--	
	004c : 180;		--	sipush: nop opd
	004d : 180;		--	   nop opd
	004e : 2f7;		--	   ld_opd_16s nxt
	            	--	
	004f : 1a1;		--	ldc: ldm cp opd
	0050 : 0f4;		--	   ld_opd_8u
	0051 : 004;		--	   add
	0052 : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	0053 : 081;		--	   wait
	0054 : 081;		--	   wait
	0055 : 2e0;		--	   ldmrd nxt // read ext. mem
	            	--	
	            	--	ldc_w:
	0056 : 1a1;		--	   ldm cp opd
	0057 : 180;		--	   nop opd
	0058 : 0f6;		--	   ld_opd_16u
	0059 : 004;		--	   add
	005a : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	005b : 081;		--	   wait
	005c : 081;		--	   wait
	005d : 2e0;		--	   ldmrd nxt // read ext. mem
	            	--	
	            	--	aload:
	            	--	fload:
	005e : 180;		--	iload: nop opd
	005f : 2ec;		--	   ld nxt
	            	--	
	            	--	aload_0:
	            	--	fload_0:
	0060 : 2e8;		--	iload_0: ld0 nxt
	            	--	aload_1:
	            	--	fload_1:
	0061 : 2e9;		--	iload_1: ld1 nxt
	            	--	aload_2:
	            	--	fload_2:
	0062 : 2ea;		--	iload_2: ld2 nxt
	            	--	aload_3:
	            	--	fload_3:
	0063 : 2eb;		--	iload_3: ld3 nxt
	            	--	
	            	--	
	            	--	astore:
	            	--	fstore:
	0064 : 180;		--	istore: nop opd
	0065 : 214;		--	   st nxt
	            	--	
	            	--	astore_0:
	            	--	fstore_0:
	0066 : 210;		--	istore_0: st0 nxt
	            	--	astore_1:
	            	--	fstore_1:
	0067 : 211;		--	istore_1: st1 nxt
	            	--	astore_2:
	            	--	fstore_2:
	0068 : 212;		--	istore_2: st2 nxt
	            	--	astore_3:
	            	--	fstore_3:
	0069 : 213;		--	istore_3: st3 nxt
	            	--	
	            	--	
	006a : 200;		--	pop: pop nxt
	006b : 000;		--	pop2: pop
	006c : 200;		--	   pop nxt
	006d : 2f8;		--	dup: dup nxt
	006e : 026;		--	dup_x1: stm a
	006f : 027;		--	   stm b
	0070 : 0a6;		--	   ldm a
	0071 : 0a7;		--	   ldm b
	0072 : 2a6;		--	   ldm a nxt
	0073 : 026;		--	dup_x2: stm a
	0074 : 027;		--	   stm b
	0075 : 028;		--	   stm c
	0076 : 0a6;		--	   ldm a
	0077 : 0a8;		--	   ldm c
	0078 : 0a7;		--	   ldm b
	0079 : 2a6;		--	   ldm a nxt
	007a : 026;		--	dup2: stm a
	007b : 027;		--	   stm b
	007c : 0a7;		--	   ldm b
	007d : 0a6;		--	   ldm a
	007e : 0a7;		--	   ldm b
	007f : 2a6;		--	   ldm a nxt
	0080 : 026;		--	dup2_x1: stm a
	0081 : 027;		--	   stm b
	0082 : 028;		--	   stm c
	0083 : 0a7;		--	   ldm b
	0084 : 0a6;		--	   ldm a
	0085 : 0a8;		--	   ldm c
	0086 : 0a7;		--	   ldm b
	0087 : 2a6;		--	   ldm a nxt
	0088 : 026;		--	dup2_x2: stm a
	0089 : 027;		--	   stm b
	008a : 028;		--	   stm c
	008b : 029;		--	   stm d
	008c : 0a7;		--	   ldm b
	008d : 0a6;		--	   ldm a
	008e : 0a9;		--	   ldm d
	008f : 0a8;		--	   ldm c
	0090 : 0a7;		--	   ldm b
	0091 : 2a6;		--	   ldm a nxt
	0092 : 026;		--	swap: stm a // not tested, javac does not generate it!
	0093 : 027;		--	   stm b
	0094 : 0a6;		--	   ldm a
	0095 : 2a7;		--	   ldm b nxt
	            	--	
	0096 : 204;		--	iadd: add nxt
	0097 : 205;		--	isub: sub nxt
	            	--	
	            	--	ineg:
	0098 : 0c5;		--	   ldi -1
	0099 : 003;		--	   xor
	009a : 0c4;		--	   ldi 1
	009b : 204;		--	   add nxt
	            	--	
	009c : 201;		--	iand: and nxt
	009d : 202;		--	ior: or nxt
	009e : 203;		--	ixor: xor nxt
	            	--	
	009f : 21d;		--	ishl: shl nxt
	00a0 : 21e;		--	ishr: shr nxt
	00a1 : 21c;		--	iushr: ushr nxt
	            	--	
	            	--	
	            	--	imul:
	00a2 : 006;		--	   stmul // store both operands and start
	00a3 : 000;		--	   pop // pop second operand
	            	--	
	00a4 : 0c6;		--	   ldi 2 // 2*7+2 wait ok!
	            	--	imul_loop:
	00a5 : 0c5;		--	   ldi -1
	00a6 : 004;		--	   add
	00a7 : 0f8;		--	   dup
	00a8 : 080;		--	   nop
	00a9 : 064;		--	   bnz imul_loop
	00aa : 080;		--	   nop
	00ab : 080;		--	   nop
	            	--	
	00ac : 000;		--	   pop // remove counter
	            	--	
	00ad : 2e6;		--	   ldmul nxt
	            	--	
	            	--	
	            	--	// 	moved to JVM.java
	            	--	// 
	            	--	// idiv:
	            	--	// 			stm	b
	            	--	// 			stm	a
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make a positiv
	            	--	// 			nop
	            	--	// 			bz	idiv_apos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	a
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// idiv_apos:
	            	--	// 			ldm	b
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make b positiv
	            	--	// 			nop
	            	--	// 			bz	idiv_bpos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	b
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	b
	            	--	// idiv_bpos:
	            	--	// 			xor					//	sign
	            	--	// 			stm	e
	            	--	// 
	            	--	// 			ldi	0
	            	--	// 			stm	c			//	c is quotient
	            	--	// 			ldi	0
	            	--	// 			stm	d			//	d is remainder
	            	--	// 			ldi	32			//	loop counter
	            	--	// idiv_loop:
	            	--	// 			ldm	c
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	c
	            	--	// 			ldm	d
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	d
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bz	idiv_noor
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	d
	            	--	// idiv_noor:
	            	--	// 			ldm	a
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bnz	idiv_nosub
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	// 			stm	d
	            	--	// 			ldm	c
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	c
	            	--	// idiv_nosub:
	            	--	// 
	            	--	// 			ldi	1
	            	--	// 			sub
	            	--	// 			dup
	            	--	// 			nop
	            	--	// 			bnz	idiv_loop
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			pop				// remove loop counter
	            	--	// 			ldm	e
	            	--	// 			nop
	            	--	// 			bz	idiv_nosign
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	c
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add	nxt
	            	--	// idiv_nosign:
	            	--	// 			ldm	c	nxt
	            	--	// 
	            	--	// irem:
	            	--	// 			stm	b
	            	--	// 			stm	a
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make a positiv
	            	--	// 			stm	e				//	sign
	            	--	// 			nop
	            	--	// 			bz	irem_apos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	a
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// irem_apos:
	            	--	// 			ldm	b
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and					// make b positiv
	            	--	// 			nop
	            	--	// 			bz	irem_bpos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	b
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	b
	            	--	// irem_bpos:
	            	--	// 
	            	--	// 			ldi	0
	            	--	// 			stm	c			//	c is quotient
	            	--	// 			ldi	0
	            	--	// 			stm	d			//	d is remainder
	            	--	// 			ldi	32			//	loop counter
	            	--	// irem_loop:
	            	--	// 			ldm	c
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	c
	            	--	// 			ldm	d
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	d
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bz	irem_noor
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	d
	            	--	// irem_noor:
	            	--	// 			ldm	a
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bnz	irem_nosub
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	// 			stm	d
	            	--	// 			ldm	c
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	c
	            	--	// irem_nosub:
	            	--	// 
	            	--	// 			ldi	1
	            	--	// 			sub
	            	--	// 			dup
	            	--	// 			nop
	            	--	// 			bnz	irem_loop
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			pop				// remove loop counter
	            	--	// 			ldm	e
	            	--	// 			nop
	            	--	// 			bz	irem_nosign
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add	nxt
	            	--	// irem_nosign:
	            	--	// 			ldm	d	nxt
	            	--	// 
	            	--	
	            	--	
	            	--	// Floating point operations in HW with FPU
	            	--	iinc:
	00ae : 1f1;		--	   ldvp opd
	00af : 0f4;		--	   ld_opd_8u
	00b0 : 004;		--	   add
	00b1 : 11a;		--	   star opd
	00b2 : 0f5;		--	   ld_opd_8s
	00b3 : 0ed;		--	   ldmi
	00b4 : 004;		--	   add
	00b5 : 215;		--	   stmi nxt
	            	--	
	            	--	i2c:
	00b6 : 0ca;		--	   ldi 65535
	00b7 : 201;		--	   and nxt
	            	--	
	            	--	ifnull:
	            	--	ifnonnull:
	            	--	ifeq:
	            	--	ifne:
	            	--	iflt:
	            	--	ifge:
	            	--	ifgt:
	            	--	ifle:
	00b8 : 180;		--	   nop opd
	00b9 : 182;		--	   jbr opd
	00ba : 000;		--	   pop
	00bb : 280;		--	   nop nxt
	            	--	
	            	--	if_acmpeq:
	            	--	if_acmpne:
	            	--	if_icmpeq:
	            	--	if_icmpne:
	            	--	if_icmplt:
	            	--	if_icmpge:
	            	--	if_icmpgt:
	            	--	if_icmple:
	00bc : 180;		--	   nop opd
	00bd : 182;		--	   jbr opd
	00be : 000;		--	   pop
	00bf : 200;		--	   pop nxt
	            	--	
	            	--	goto:
	00c0 : 180;		--	   nop opd
	00c1 : 182;		--	   jbr opd
	00c2 : 080;		--	   nop
	00c3 : 280;		--	   nop nxt
	            	--	
	            	--	
	            	--	   // new 'customized' getfield
	            	--	   // index is now the address
	            	--	getstatic_ref:
	            	--	getstatic:
	00c4 : 180;		--	   nop opd
	00c5 : 180;		--	   nop opd
	00c6 : 0f6;		--	   ld_opd_16u
	            	--	
	00c7 : 008;		--	   stmra
	00c8 : 081;		--	   wait
	00c9 : 081;		--	   wait
	00ca : 2e0;		--	   ldmrd nxt
	            	--	
	            	--	   // new 'customized' getfield
	            	--	   // index is now the address
	            	--	putstatic:
	00cb : 180;		--	   nop opd
	00cc : 180;		--	   nop opd
	00cd : 0f6;		--	   ld_opd_16u
	            	--	
	00ce : 007;		--	   stmwa // write ext. mem address
	            	--	//			nop				// ??? tos is val
	00cf : 009;		--	   stmwd // write ext. mem data
	00d0 : 081;		--	   wait
	00d1 : 081;		--	   wait
	00d2 : 280;		--	   nop nxt
	            	--	
	            	--	   // new 'customized' getfield instructions
	            	--	   // generated by JOPizer
	            	--	   // at the moment it's just a copy of the original
	            	--	getfield_ref:
	            	--	getfield:
	00d3 : 180;		--	   nop opd // push index
	00d4 : 180;		--	   nop opd
	00d5 : 0f6;		--	   ld_opd_16u
	            	--	jopsys_getfield: // version from Native
	00d6 : 00c;		--	   stgf // let the HW do the work
	00d7 : 000;		--	   pop
	00d8 : 081;		--	   wait
	00d9 : 081;		--	   wait
	00da : 2e0;		--	   ldmrd nxt // read result
	            	--	
	            	--	putfield:
	00db : 126;		--	   stm a opd // push index
	00dc : 180;		--	   nop opd
	00dd : 0f6;		--	   ld_opd_16u
	00de : 0a6;		--	   ldm a
	            	--	jopsys_putfield: // Version from Native
	00df : 00d;		--	   stpf // let the HW do the work
	00e0 : 000;		--	   pop
	00e1 : 081;		--	   wait
	00e2 : 081;		--	   wait
	00e3 : 200;		--	   pop nxt
	            	--	
	            	--	newarray:
	00e4 : 180;		--	   nop opd
	00e5 : 0f4;		--	   ld_opd_8u
	00e6 : 026;		--	   stm a
	00e7 : 0f2;		--	   ldjpc
	00e8 : 0c6;		--	   ldi 2
	00e9 : 005;		--	   sub
	00ea : 019;		--	   stjpc // get last byte code
	00eb : 080;		--	   nop // ???
	00ec : 080;		--	   nop // one more now (2004-04-06) ?
	00ed : 0a6;		--	   ldm a
	00ee : 0a3;		--	   ldm jjp
	00ef : 180;		--	   nop opd
	00f0 : 0f4;		--	   ld_opd_8u
	00f1 : 0cb;		--	   ldi 255
	00f2 : 101;		--	   and opd // remove type info
	00f3 : 0f8;		--	   dup
	00f4 : 004;		--	   add // *2
	00f5 : 004;		--	   add // jjp+2*bc
	            	--	
	            	--	// invoke JVM.fxxx();
	00f6 : 0c4;		--	   ldi 1
	00f7 : 080;		--	   nop
	00f8 : 065;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	00f9 : 080;		--	   nop
	00fa : 080;		--	   nop
	            	--	
	            	--	
	            	--	arraylength:
	            	--	
	00fb : 0c4;		--	   ldi 1
	00fc : 004;		--	   add // arrayref+1 (in handle)
	00fd : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	00fe : 081;		--	   wait
	00ff : 081;		--	   wait
	0100 : 2e0;		--	   ldmrd nxt // read ext. mem
	            	--	
	            	--	
	            	--	//aastore: is now in JVM.java for the write barrier
	            	--	bastore:
	            	--	castore:
	            	--	fastore:
	            	--	iastore:
	            	--	sastore:
	            	--	// new HW version :-)))
	0101 : 00b;		--	   stast
	0102 : 000;		--	   pop
	0103 : 000;		--	   pop
	0104 : 081;		--	   wait
	0105 : 081;		--	   wait
	0106 : 280;		--	   nop nxt
	            	--	
	            	--	//*******************************
	            	--	// test for oohw change
	            	--	//			ldi	6			// 7*5+2+1=38
	            	--	//dly7:
	            	--	//			dup
	            	--	//			nop
	            	--	//			bnz	dly7
	            	--	//			ldi	-1			// decrement in branch slot
	            	--	//			add
	            	--	//			pop				// remove counter
	            	--	//			nop
	            	--	//*******************************
	            	--	
	            	--	// original SW version
	            	--	//			stm	a				// value
	            	--	//			stm	b				// index
	            	--	//			// arrayref is TOS
	            	--	//			dup					// for null pointer check
	            	--	//			dup					// for bound check, one cycle wait for bz
	            	--	//			bz	null_pointer	// 
	            	--	//			// we do the following in the
	            	--	//			// branch slot -> one more element
	            	--	//			// from the former dup on the stack
	            	--	//			ldi	1
	            	--	//			add					// arrayref+1
	            	--	//			stmra				// read ext. mem, mem_bsy comes one cycle later
	            	--	//			wait				// is this ok? - wait in branch slot
	            	--	//			wait
	            	--	//			ldmrd		 		// read ext. mem (array length)
	            	--	//
	            	--	//			ldi	1
	            	--	//			sub					// length-1
	            	--	//			ldm	b				// index
	            	--	//			sub					// TOS = length-1-index
	            	--	//			ldm	b				// check if index is negativ
	            	--	//			or					// is one of both checks negativ?
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	//			and
	            	--	//			nop
	            	--	//			bnz	array_bound
	            	--	//			nop
	            	--	//			nop
	            	--	//
	            	--	//// we could save one or two cycles when
	            	--	//// starting the read in the branch slot
	            	--	//			stmra				// read handle indirection
	            	--	//			wait				// for the GC
	            	--	//			wait
	            	--	//			ldmrd
	            	--	//			ldm	b
	            	--	//			add					// index+arrayref
	            	--	//
	            	--	//			stmwa				// write ext. mem address
	            	--	//			ldm	a
	            	--	//			stmwd				// write ext. mem data
	            	--	//			wait
	            	--	//			wait
	            	--	//			nop	nxt
	            	--	
	            	--	aaload:
	            	--	baload:
	            	--	caload:
	            	--	faload:
	            	--	iaload:
	            	--	saload:
	            	--	// new HW version :-)))
	0107 : 00a;		--	   stald
	0108 : 000;		--	   pop
	0109 : 081;		--	   wait
	010a : 081;		--	   wait
	010b : 2e0;		--	   ldmrd nxt
	            	--	
	            	--	//*******************************
	            	--	// test for oohw change
	            	--	//			ldi	5			// 6*5+2+3=35
	            	--	//dly6:
	            	--	//			dup
	            	--	//			nop
	            	--	//			bnz	dly6
	            	--	//			ldi	-1			// decrement in branch slot
	            	--	//			add
	            	--	//			pop				// remove counter
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop
	            	--	//*******************************
	            	--	
	            	--	// original SW version
	            	--	//
	            	--	//	ideas for enhancements:
	            	--	//		array pointer points to length and not the first element
	            	--	//		load and checks in memory interface
	            	--	//
	            	--	//			stm	b				// index
	            	--	//			// arrayref is TOS
	            	--	//			dup					// for null pointer check
	            	--	//			dup					// for bound check, one cycle wait for bz
	            	--	//			bz	null_pointer	// 
	            	--	//			// we do the following in the
	            	--	//			// branch slot -> one more element
	            	--	//			// from the former dup on the stack
	            	--	//			ldi	1
	            	--	//			add					// arrayref+1
	            	--	//
	            	--	//			stmra				// read array length
	            	--	//			wait				// is this ok? - wait in branch slot
	            	--	//			wait
	            	--	//			ldmrd		 		// read ext. mem (array length)
	            	--	//
	            	--	//			ldi	1
	            	--	//			add					// length+1
	            	--	//			ldm	b				// index
	            	--	//			sub					// TOS = length-1-index
	            	--	//			ldm	b				// check if index is negativ
	            	--	//			or					// is one of both checks neagtv?
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	//			and
	            	--	//			nop
	            	--	//			bnz	array_bound
	            	--	//			nop
	            	--	//			nop
	            	--	//
	            	--	//// we could save one ot two cycles when
	            	--	//// starting the read in the branch slot
	            	--	//			stmra				// read handle indirection
	            	--	//			wait				// for the GC
	            	--	//			wait
	            	--	//			ldmrd
	            	--	//			ldm	b
	            	--	//			add					// index+arrayref
	            	--	//
	            	--	//			stmra				// read ext. mem, mem_bsy comes one cycle later
	            	--	//			wait
	            	--	//			wait
	            	--	//			ldmrd		 nxt	// read ext. mem
	            	--	
	            	--	
	            	--	monitorenter:
	010c : 000;		--	    pop // drop reference
	            	--	//			bz null_pointer		// null pointer check
	010d : 0cc;		--	   ldi io_int_ena
	010e : 007;		--	   stmwa // write ext. mem address
	010f : 0c3;		--	   ldi 0
	0110 : 009;		--	   stmwd // write ext. mem data
	0111 : 0a5;		--	   ldm moncnt
	0112 : 0c4;		--	   ldi 1
	0113 : 004;		--	   add
	0114 : 081;		--	   wait
	0115 : 081;		--	   wait
	0116 : 025;		--	   stm moncnt
	            	--	   // request the global lock
	0117 : 0cd;		--	   ldi io_lock
	0118 : 007;		--	   stmwa // write ext. mem address
	0119 : 0c4;		--	   ldi 1
	011a : 009;		--	   stmwd // write ext. mem data
	011b : 081;		--	   wait
	011c : 081;		--	   wait
	011d : 280;		--	   nop nxt
	            	--	
	            	--	monitorexit:
	011e : 000;		--	   pop // drop reference
	            	--	//			bz null_pointer		// null pointer check
	011f : 0a5;		--	   ldm moncnt
	0120 : 0c4;		--	   ldi 1
	0121 : 005;		--	   sub
	0122 : 0f8;		--	   dup
	0123 : 025;		--	   stm moncnt
	0124 : 066;		--	   bnz mon_no_ena
	            	--	   // can be exec in in branch delay?
	            	--	   // up to now yes, but we change the write
	            	--	   // some time....
	            	--	   // nop
	            	--	   // nop
	            	--	   // free the global lock
	0125 : 0cd;		--	   ldi io_lock
	0126 : 007;		--	   stmwa // write ext. mem address
	0127 : 0c3;		--	   ldi 0
	0128 : 009;		--	   stmwd // write ext. mem data
	0129 : 081;		--	   wait
	012a : 081;		--	   wait
	012b : 0cc;		--	   ldi io_int_ena
	012c : 007;		--	   stmwa
	012d : 0c4;		--	   ldi 1
	012e : 009;		--	   stmwd // write ext. mem data
	012f : 081;		--	   wait
	0130 : 081;		--	   wait
	0131 : 280;		--	mon_no_ena: nop nxt
	            	--	
	            	--	//
	            	--	//	invoke and return functions
	            	--	//
	            	--	
	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	
	            	--	//
	            	--	//	call.inc
	            	--	//
	            	--	//		include file for invoke and return functions
	            	--	//
	            	--	//	2004-08-19	extracted from jvm.asm
	            	--	//	
	            	--	//	see changlog in jvm.asm
	            	--	//
	            	--	
	            	--	//
	            	--	//	local vars for tmp storage
	            	--	//
	            	--	old_mp ?
	            	--	old_vp ?
	            	--	old_jpc ?
	            	--	
	            	--	old_cp ? // for now save it on stack
	            	--	
	            	--	start ?
	            	--	end ?
	            	--	args ?
	            	--	varcnt ?
	            	--	
	            	--	
	            	--	invokespecial: // is it really equivalent ????? (not really)
	            	--	      // there is an object ref on stack (but arg counts for it)
	            	--	      // is called for privat methods AND <init>!!!
	            	--	invokestatic:
	            	--	
	            	--	      // mp = readMem(cp+idx);
	0132 : 1a1;		--	   ldm cp opd
	0133 : 180;		--	   nop opd
	0134 : 0f6;		--	   ld_opd_16u
	0135 : 004;		--	   add
	            	--	
	            	--	invoke_main: // jmp with pointer to pointer to mp on TOS
	            	--	
	0136 : 008;		--	   stmra // read 'real' mp
	0137 : 081;		--	   wait
	0138 : 081;		--	   wait
	0139 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	            	--	jopsys_invoke: // called from Startup.boot() with pointer to main() method struct
	            	--	invoke: // jmp with mp on TOS (pointer to method struct)
	            	--	
	013a : 0c4;		--	   ldi 1
	            	--	//			nop			// mp is != 0
	013b : 067;		--	   bnz invoke_vpsave
	013c : 0f1;		--	   ldvp // save vp
	013d : 02e;		--	   stm old_vp // in branch slots
	            	--	
	            	--	
	            	--	
	            	--	invokeinterface:
	            	--	
	013e : 1a1;		--	   ldm cp opd
	013f : 180;		--	   nop opd
	0140 : 0f6;		--	   ld_opd_16u
	0141 : 104;		--	   add opd
	            	--	
	0142 : 108;		--	   stmra opd // read constant
	0143 : 081;		--	   wait
	0144 : 081;		--	   wait
	0145 : 0e0;		--	   ldmrd // off on TOS
	            	--	
	0146 : 0f8;		--	   dup
	0147 : 0cb;		--	   ldi 255
	0148 : 001;		--	   and
	0149 : 026;		--	   stm a // arg count (without objectref)
	014a : 0ce;		--	   ldi 8
	014b : 01c;		--	   ushr
	014c : 027;		--	   stm b // offset in method table
	            	--	
	014d : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	014e : 0c4;		--	   ldi 1 // 'real' sp
	014f : 004;		--	   add
	0150 : 0a6;		--	   ldm a
	0151 : 005;		--	   sub
	            	--	
	0152 : 01a;		--	   star // address of objectref
	0153 : 080;		--	   nop
	0154 : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	            	--	
	0155 : 0f8;		--	   dup // null pointer check
	0156 : 080;		--	   nop
	0157 : 048;		--	   bz null_pointer
	0158 : 0f1;		--	   ldvp // save vp in branch slot
	0159 : 02e;		--	   stm old_vp
	            	--	
	015a : 0c4;		--	   ldi 1 // at address ref+1 (in the handle) is the pointer to method table
	015b : 004;		--	   add
	015c : 008;		--	   stmra // read pointer to method table
	015d : 081;		--	   wait
	015e : 081;		--	   wait
	015f : 0e0;		--	   ldmrd // vt on TOS
	            	--	
	0160 : 0c4;		--	   ldi 1 // pointer to interface table
	0161 : 005;		--	   sub // befor method table
	0162 : 008;		--	   stmra // read interface table address
	0163 : 081;		--	   wait
	0164 : 081;		--	   wait
	0165 : 0e0;		--	   ldmrd // it on TOS
	            	--	
	0166 : 0a7;		--	   ldm b
	0167 : 004;		--	   add // add offset
	0168 : 008;		--	   stmra // read method pointer
	0169 : 081;		--	   wait // from interface table
	016a : 081;		--	   wait
	016b : 0e0;		--	   ldmrd // mp on TOS
	            	--	
	016c : 0c4;		--	   ldi 1
	            	--	//			nop		// mp is != 0
	016d : 069;		--	   bnz invoke_vpsave
	016e : 080;		--	   nop
	016f : 080;		--	   nop
	            	--	
	            	--	invokesuper: // this was invokespecial, replaced in JOPizer when calling super methods
	0170 : 1a1;		--	   ldm cp opd
	0171 : 180;		--	   nop opd
	0172 : 0f6;		--	   ld_opd_16u
	0173 : 004;		--	   add
	            	--	
	0174 : 008;		--	   stmra // read constant
	0175 : 081;		--	   wait
	0176 : 081;		--	   wait
	0177 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	0178 : 0f8;		--	   dup
	0179 : 0cb;		--	   ldi 255
	017a : 001;		--	   and
	017b : 026;		--	   stm a // arg count (without objectref)
	017c : 0ce;		--	   ldi 8
	017d : 01c;		--	   ushr
	017e : 027;		--	   stm b // offset in method table
	            	--	
	017f : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	0180 : 0c4;		--	   ldi 1 // 'real' sp
	0181 : 004;		--	   add
	0182 : 0a6;		--	   ldm a
	0183 : 005;		--	   sub
	            	--	
	0184 : 01a;		--	   star // address of objectref
	0185 : 080;		--	   nop
	0186 : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	            	--	
	0187 : 0f8;		--	   dup // null pointer check
	0188 : 080;		--	   nop
	0189 : 04a;		--	   bz null_pointer
	018a : 0f1;		--	   ldvp // save vp in branch slot
	018b : 02e;		--	   stm old_vp
	            	--	
	018c : 0c4;		--	   ldi 1 // at address ref+1 (in the handle) is the pointer to method table
	018d : 004;		--	   add
	            	--	
	018e : 008;		--	   stmra // read pointer to method table of this
	018f : 081;		--	   wait
	0190 : 081;		--	   wait
	0191 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	0192 : 0cf;		--	   ldi -2 // superclass pointer is at vt-2
	0193 : 004;		--	   add
	            	--	
	0194 : 008;		--	   stmra // read pointer to superclass
	0195 : 081;		--	   wait
	0196 : 081;		--	   wait
	0197 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	0198 : 0c9;		--	   ldi 5 // "super" method table is at superclass+5
	0199 : 004;		--	   add
	            	--	
	019a : 0c4;		--	   ldi 1
	            	--	//			nop		// mp is != 0
	019b : 06b;		--	   bnz invoke_addoffset
	019c : 080;		--	   nop
	019d : 080;		--	   nop
	            	--	
	019e : 080;		--	nop // to keep offtbl.vhd short enough....
	            	--	
	            	--	invokevirtual:
	            	--	
	019f : 1a1;		--	   ldm cp opd
	01a0 : 180;		--	   nop opd
	01a1 : 0f6;		--	   ld_opd_16u
	01a2 : 004;		--	   add
	            	--	
	01a3 : 008;		--	   stmra // read constant
	01a4 : 081;		--	   wait
	01a5 : 081;		--	   wait
	01a6 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	01a7 : 0f8;		--	   dup
	01a8 : 0cb;		--	   ldi 255
	01a9 : 001;		--	   and
	01aa : 026;		--	   stm a // arg count (without objectref)
	01ab : 0ce;		--	   ldi 8
	01ac : 01c;		--	   ushr
	01ad : 027;		--	   stm b // offset in method table
	            	--	
	01ae : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	01af : 0c4;		--	   ldi 1 // 'real' sp
	01b0 : 004;		--	   add
	01b1 : 0a6;		--	   ldm a
	01b2 : 005;		--	   sub
	            	--	
	01b3 : 01a;		--	   star // address of objectref
	01b4 : 080;		--	   nop
	01b5 : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	            	--	
	01b6 : 0f8;		--	   dup // null pointer check
	01b7 : 080;		--	   nop
	01b8 : 04c;		--	   bz null_pointer
	01b9 : 0f1;		--	   ldvp // save vp in branch slot
	01ba : 02e;		--	   stm old_vp
	            	--	
	01bb : 0c4;		--	   ldi 1 // at address ref+1 (in the handle) is the pointer to method table
	01bc : 004;		--	   add
	            	--	
	01bd : 008;		--	   stmra // read pointer to method table
	01be : 081;		--	   wait
	01bf : 081;		--	   wait
	01c0 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	            	--	invoke_addoffset:
	01c1 : 0a7;		--	   ldm b
	01c2 : 004;		--	   add // add offset
	            	--	
	            	--	
	            	--	
	            	--	invoke_vpsave: // vp is allready saved in old_vp
	            	--	        // used for invokestatic and invokevirtual
	            	--	
	            	--	//*******************************
	            	--	// test for oohw change
	            	--	// invoke would be 102, invokestatic would be 75
	            	--	// we use 89 as arithmetic mean
	            	--	//			ldi	16			// 17*5+2+2=102
	            	--	//dlyl:
	            	--	//			dup
	            	--	//			nop
	            	--	//			bnz	dlyl
	            	--	//			ldi	-1			// decrement in branch slot
	            	--	//			add
	            	--	//			pop				// remove counter
	            	--	//			nop
	            	--	//			nop
	            	--	//*******************************
	            	--	
	            	--	//	mp is on TOS
	            	--	//		we will not read mem[mp] now,
	            	--	//		this is done in load_bc
	01c3 : 0f8;		--	   dup
	01c4 : 0c4;		--	   ldi 1
	01c5 : 004;		--	   add
	01c6 : 008;		--	   stmra // read cp+arrg/locals count
	01c7 : 0a0;		--	   ldm mp
	01c8 : 02d;		--	   stm old_mp
	01c9 : 020;		--	   stm mp
	            	--	
	01ca : 081;		--	   wait
	01cb : 081;		--	   wait
	01cc : 0e0;		--	   ldmrd // cp...
	            	--	
	            	--	     // cp = readMem(mp+1);
	            	--	     // int locals = (cp>>>5) & 0x01f;
	            	--	     // int args = cp & 0x01f;
	            	--	     // cp >>>= 10;
	            	--	
	            	--	// get 'old' (= current) bc start address
	            	--	// and store relative jpc in stack frame
	01cd : 0f2;		--	   ldjpc
	01ce : 0e7;		--	   ldbcstart
	01cf : 005;		--	   sub // relative pc
	01d0 : 02f;		--	   stm old_jpc
	            	--	// TODO: ldjpc and subtraction could be moved down
	            	--	
	            	--	// get method start address and length
	            	--	
	01d1 : 0a0;		--	   ldm mp
	01d2 : 008;		--	   stmra
	            	--	
	01d3 : 0a1;		--	   ldm cp
	01d4 : 030;		--	   stm old_cp
	            	--	
	01d5 : 081;		--	   wait
	01d6 : 081;		--	   wait
	01d7 : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	            	--	     // int len = start & 0x03ff;
	            	--	     // start >>>= 10;
	            	--	// start bytecode load....
	01d8 : 00f;		--	   stbcrd
	            	--	
	            	--	
	01d9 : 0f8;		--	   dup
	01da : 0d0;		--	   ldi 31
	01db : 001;		--	   and
	01dc : 033;		--	   stm args
	01dd : 0c9;		--	   ldi 5
	01de : 01c;		--	   ushr
	01df : 0f8;		--	   dup
	01e0 : 0d0;		--	   ldi 31
	01e1 : 001;		--	   and
	01e2 : 034;		--	   stm varcnt
	01e3 : 0c9;		--	   ldi 5
	01e4 : 01c;		--	   ushr
	01e5 : 021;		--	   stm cp
	            	--	
	            	--	
	            	--	old_sp ?
	            	--	real_sp ?
	            	--	
	            	--	
	            	--	//
	            	--	// tos and tos-1 are allready written back to memory
	            	--	//
	            	--	    // int old_sp = sp-args;
	            	--	    // vp = old_sp+1;
	            	--	    // sp += varcnt;
	            	--	
	01e6 : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	01e7 : 0c4;		--	   ldi 1 // 'real' sp			da sp auf rd adr zeigt
	01e8 : 004;		--	   add
	01e9 : 0f8;		--	   dup
	01ea : 0b3;		--	   ldm args
	01eb : 005;		--	   sub
	01ec : 035;		--	   stm old_sp
	01ed : 0b5;		--	   ldm old_sp
	01ee : 0c4;		--	   ldi 1
	01ef : 004;		--	   add
	01f0 : 018;		--	   stvp
	            	--	   // sp still on TOS
	01f1 : 0b4;		--	   ldm varcnt // 'real' varcnt (=locals-args)
	01f2 : 004;		--	   add
	            	--	
	01f3 : 080;		--	   nop // written in adr/read stage!
	01f4 : 01b;		--	   stsp
	01f5 : 000;		--	   pop // flush reg., sp reg is sp-2 again
	01f6 : 000;		--	   pop // could really be optimized :-(
	            	--	
	            	--	    // stack[++sp] = old_sp;
	            	--	    // stack[++sp] = cache.corrPc(pc);
	            	--	     // in VarBlockCache:
	            	--	     // save pc relative to start address of the method
	            	--	     // return (pc - currentBlock*blockSize) & mask;
	            	--	    // stack[++sp] = old_vp;
	            	--	    // stack[++sp] = old_cp;
	            	--	    // stack[++sp] = old_mp;
	            	--	    // 
	            	--	    // pc = cache.invoke(start, len);
	            	--	     // in VarBlockCache:
	            	--	     // test or load cache, return start address (block number * size)
	            	--	     // int off = testCache(start, len);
	            	--	     // return off;
	            	--	
	01f7 : 0b5;		--	   ldm old_sp
	01f8 : 0af;		--	   ldm old_jpc
	            	--	// without cache load jpc here
	            	--	//		ldi 0
	            	--	//		stjpc
	            	--	// bc start address is a 'few' cycles after stbcrd available
	01f9 : 0e7;		--	   ldbcstart // for future cache
	01fa : 019;		--	   stjpc
	01fb : 0ae;		--	   ldm old_vp
	01fc : 0b0;		--	   ldm old_cp
	01fd : 0ad;		--	   ldm old_mp
	            	--	
	            	--	// wait on bytecode load from memory system
	01fe : 081;		--	   wait
	01ff : 081;		--	   wait
	0200 : 280;		--	   nop nxt
	            	--	// end load_bc
	            	--	
	            	--	//
	            	--	//	thats the pipeline delay from stjpc - jpc -
	            	--	//	rdaddress - jpaddr - pc!
	            	--	//
	            	--	//		could be simpler if a different command to store
	            	--	//		write address for jbc (or use DMA in mem.vhd!)
	            	--	//
	            	--	//			stjpc
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop	nxt
	            	--	//
	            	--	
	            	--	areturn:
	            	--	freturn:
	            	--	ireturn:
	0201 : 026;		--	   stm a // store return value
	0202 : 0f8;		--	   dup // mp is on tos
	0203 : 008;		--	   stmra
	0204 : 020;		--	   stm mp
	0205 : 021;		--	   stm cp
	0206 : 018;		--	   stvp
	0207 : 081;		--	   wait // wait for mem(mp)
	0208 : 081;		--	   wait
	0209 : 0e0;		--	   ldmrd // read ext. mem
	020a : 00f;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	020b : 02f;		--	   stm old_jpc // save realtive pc
	            	--	
	020c : 080;		--	   nop // written in adr/read stage!
	020d : 01b;		--	   stsp // last is new sp
	020e : 000;		--	   pop // flash tos, tos-1 (registers)
	020f : 000;		--	   pop // sp must be two lower, points to rd adr
	            	--	
	0210 : 0e7;		--	   ldbcstart // start block of method
	0211 : 0af;		--	   ldm old_jpc // plus relative jpc
	0212 : 004;		--	   add
	0213 : 019;		--	   stjpc
	            	--	
	0214 : 0a6;		--	   ldm a // load return value
	            	--	// wait on bytecode load from memory system
	0215 : 081;		--	   wait
	0216 : 081;		--	   wait
	0217 : 280;		--	   nop nxt
	            	--	
	            	--	dreturn:
	            	--	lreturn:
	0218 : 026;		--	   stm a // store return value
	0219 : 027;		--	   stm b
	021a : 0f8;		--	   dup // mp is on tos
	021b : 008;		--	   stmra
	021c : 020;		--	   stm mp
	021d : 021;		--	   stm cp
	021e : 018;		--	   stvp
	021f : 081;		--	   wait // wait for mem(mp)
	0220 : 081;		--	   wait
	0221 : 0e0;		--	   ldmrd // read ext. mem
	0222 : 00f;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	0223 : 02f;		--	   stm old_jpc // save realtive pc
	            	--	
	0224 : 080;		--	   nop // written in adr/read stage!
	0225 : 01b;		--	   stsp // last is new sp
	0226 : 000;		--	   pop // flash tos, tos-1 (registers)
	0227 : 000;		--	   pop // sp must be two lower, points to rd adr
	            	--	
	0228 : 0e7;		--	   ldbcstart // start block of method
	0229 : 0af;		--	   ldm old_jpc // plus relative jpc
	022a : 004;		--	   add
	022b : 019;		--	   stjpc
	            	--	
	022c : 0a7;		--	   ldm b
	022d : 0a6;		--	   ldm a // load return value
	            	--	// wait on bytecode load from memory system
	022e : 081;		--	   wait
	022f : 081;		--	   wait
	0230 : 280;		--	   nop nxt
	            	--	
	            	--	return:
	            	--	    // mp = stack[sp--];
	            	--	    // cp = stack[sp--];
	            	--	    // vp = stack[sp--];
	            	--	    // pc = stack[sp--];
	            	--	    // sp = stack[sp--];
	            	--	    // 
	            	--	    // int start = readMem(mp);
	            	--	    // int len = start & 0x03ff;
	            	--	    // start >>>= 10;
	            	--	    // pc = cache.ret(start, len, pc);
	            	--	     // in VarBlockCache:
	            	--	     // int off = testCache(start, len);
	            	--	     // return (off+pc) & mask;
	            	--	
	            	--	
	            	--	
	0231 : 0f8;		--	   dup // mp is on tos
	0232 : 008;		--	   stmra
	0233 : 020;		--	   stm mp
	0234 : 021;		--	   stm cp
	0235 : 018;		--	   stvp
	0236 : 081;		--	   wait // wait for mem(mp)
	0237 : 081;		--	   wait
	0238 : 0e0;		--	   ldmrd // read ext. mem
	0239 : 00f;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	023a : 02f;		--	   stm old_jpc // save realtive pc
	            	--	
	023b : 080;		--	   nop // written in adr/read stage!
	023c : 01b;		--	   stsp // last is new sp
	            	--	
	023d : 0e7;		--	   ldbcstart // start block of method
	023e : 0af;		--	   ldm old_jpc // plus relative jpc
	023f : 004;		--	   add
	0240 : 019;		--	   stjpc
	            	--	
	0241 : 000;		--	   pop // flash tos, tos-1 (registers)
	0242 : 000;		--	   pop // sp must be two lower, points to rd adr
	            	--	// wait on bytecode load from memory system
	0243 : 081;		--	   wait
	0244 : 081;		--	   wait
	0245 : 280;		--	   nop nxt
	            	--	// end load_bc
	            	--	
	            	--	
	            	--	//
	            	--	//	null pointer
	            	--	//		call JVMHelp.nullPoint();
	            	--	//
	            	--	
	            	--	null_pointer:
	0246 : 081;		--	   wait // just for shure if we jump during
	0247 : 081;		--	   wait // a memory transaction to this point
	0248 : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	            	--	        // method after methods inherited from Object
	0249 : 0c6;		--	   ldi 2 // second method (index 1 * 2 word);
	024a : 004;		--	   add
	            	--	
	024b : 0c4;		--	   ldi 1
	024c : 080;		--	   nop
	024d : 06d;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	024e : 080;		--	   nop
	024f : 080;		--	   nop
	            	--	
	            	--	
	            	--	//
	            	--	//	array bound exception
	            	--	//		call JVMHelp.arrayBound();
	            	--	//
	            	--	
	            	--	array_bound:
	0250 : 081;		--	   wait // just for shure if we jump during
	0251 : 081;		--	   wait // a memory transaction to this point
	0252 : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	            	--	        // method after methods inherited from Object
	0253 : 0c8;		--	   ldi 4 // third method (index 2 * 2 word);
	0254 : 004;		--	   add
	            	--	
	0255 : 0c4;		--	   ldi 1
	0256 : 080;		--	   nop
	0257 : 06e;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	0258 : 080;		--	   nop
	0259 : 080;		--	   nop
	            	--	
	            	--	//		
	            	--	// long bytecodes
	            	--	//
	            	--	
	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	
	            	--	//
	            	--	//	Include file for long bytecodes
	            	--	//
	            	--	//	Arrangement of longs in the memory:
	            	--	//		as usual in Java - high word first (at lower address)
	            	--	//		thet stack grows to higher addresses => TOS is LOWER part
	            	--	//		of long!
	            	--	
	            	--	// lreturn: is in jvm_call.inc
	            	--	
	            	--	ldc2_w:
	025a : 1a1;		--	   ldm cp opd
	025b : 180;		--	   nop opd
	025c : 0f6;		--	   ld_opd_16u
	025d : 004;		--	   add
	025e : 0f8;		--	   dup
	            	--	
	025f : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	            	--	
	0260 : 0c4;		--	   ldi 1
	0261 : 004;		--	   add // address for next word
	            	--	
	0262 : 081;		--	   wait
	0263 : 081;		--	   wait
	            	--	
	0264 : 0e0;		--	   ldmrd // first word
	0265 : 026;		--	   stm a
	            	--	
	0266 : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	0267 : 0a6;		--	   ldm a // first word again on stack
	0268 : 081;		--	   wait
	0269 : 081;		--	   wait
	026a : 2e0;		--	   ldmrd nxt // second word
	            	--	
	026b : 0c3;		--	lconst_0: ldi 0
	026c : 2c3;		--	   ldi 0 nxt
	026d : 0c3;		--	lconst_1: ldi 0
	026e : 2c4;		--	   ldi 1 nxt // TOS is low part
	            	--	
	026f : 026;		--	l2i: stm a // low part
	0270 : 000;		--	   pop // drop high word
	0271 : 2a6;		--	   ldm a nxt // low on stack
	            	--	
	            	--	dload_0:
	0272 : 0e8;		--	lload_0: ld0 // high word
	0273 : 2e9;		--	   ld1 nxt // low word
	            	--	dload_1:
	0274 : 0e9;		--	lload_1: ld1
	0275 : 2ea;		--	   ld2 nxt
	            	--	dload_2:
	0276 : 0ea;		--	lload_2: ld2
	0277 : 2eb;		--	   ld3 nxt
	            	--	dload_3:
	0278 : 0f1;		--	lload_3: ldvp // there is no ld4
	0279 : 0f8;		--	   dup
	027a : 0c4;		--	   ldi 1
	027b : 004;		--	   add
	027c : 018;		--	   stvp
	027d : 026;		--	   stm a
	027e : 0ea;		--	   ld2
	027f : 0eb;		--	   ld3
	0280 : 0a6;		--	   ldm a // restore vp
	0281 : 018;		--	   stvp
	0282 : 280;		--	   nop nxt
	            	--	
	            	--	dload:
	0283 : 0f1;		--	lload: ldvp
	0284 : 1f8;		--	   dup opd
	0285 : 0f4;		--	   ld_opd_8u
	0286 : 004;		--	   add
	0287 : 018;		--	   stvp
	0288 : 026;		--	   stm a
	0289 : 0e8;		--	   ld0
	028a : 0e9;		--	   ld1
	028b : 0a6;		--	   ldm a
	028c : 018;		--	   stvp
	028d : 280;		--	   nop nxt
	            	--	
	            	--	dstore_0:
	028e : 011;		--	lstore_0: st1 // low word
	028f : 210;		--	   st0 nxt // high word
	            	--	dstore_1:
	0290 : 012;		--	lstore_1: st2
	0291 : 211;		--	   st1 nxt
	            	--	dstore_2:
	0292 : 013;		--	lstore_2: st3
	0293 : 212;		--	   st2 nxt
	            	--	dstore_3:
	0294 : 0f1;		--	lstore_3: ldvp // there is no ld4
	0295 : 0f8;		--	   dup
	0296 : 0c4;		--	   ldi 1
	0297 : 004;		--	   add
	0298 : 018;		--	   stvp
	0299 : 026;		--	   stm a
	029a : 013;		--	   st3
	029b : 012;		--	   st2
	029c : 0a6;		--	   ldm a // restore vp
	029d : 018;		--	   stvp
	029e : 280;		--	   nop nxt
	            	--	
	            	--	dstore:
	029f : 0f1;		--	lstore: ldvp
	02a0 : 1f8;		--	   dup opd
	02a1 : 0f4;		--	   ld_opd_8u
	02a2 : 004;		--	   add
	02a3 : 018;		--	   stvp
	02a4 : 026;		--	   stm a
	02a5 : 011;		--	   st1
	02a6 : 010;		--	   st0
	02a7 : 0a6;		--	   ldm a
	02a8 : 018;		--	   stvp
	02a9 : 280;		--	   nop nxt
	            	--	
	            	--	getstatic_long:
	            	--	    // int addr = readOpd16u();
	            	--	    // stack[++sp] = readMem(addr);
	            	--	    // stack[++sp] = readMem(addr+1);
	            	--	
	02aa : 180;		--	   nop opd
	02ab : 180;		--	   nop opd
	02ac : 0f6;		--	   ld_opd_16u
	            	--	
	02ad : 0f8;		--	   dup
	            	--	
	02ae : 008;		--	   stmra
	02af : 0c4;		--	   ldi 1
	02b0 : 004;		--	   add
	02b1 : 026;		--	   stm a
	02b2 : 081;		--	   wait
	02b3 : 081;		--	   wait
	02b4 : 0e0;		--	   ldmrd // read high word
	            	--	
	02b5 : 0a6;		--	   ldm a
	02b6 : 008;		--	   stmra
	02b7 : 081;		--	   wait
	02b8 : 081;		--	   wait
	02b9 : 2e0;		--	   ldmrd nxt // read low word
	            	--	
	            	--	
	            	--	putstatic_long:
	            	--	    // int addr = readOpd16u();
	            	--	    // writeMem(addr+1, stack[sp--]);
	            	--	    // writeMem(addr, stack[sp--]);
	            	--	
	02ba : 127;		--	   stm b opd // save low word
	02bb : 126;		--	   stm a opd // save high word
	            	--	   // could also be done to keep values on
	            	--	   // stack, but first store at addr+1 (like 
	            	--	   // in Java simulation)
	            	--	
	02bc : 0f6;		--	   ld_opd_16u
	            	--	
	02bd : 0f8;		--	   dup
	            	--	
	02be : 007;		--	   stmwa // write ext. mem address
	02bf : 0a6;		--	   ldm a // restore value
	02c0 : 009;		--	   stmwd // write ext. mem data
	02c1 : 0c4;		--	   ldi 1
	02c2 : 004;		--	   add
	02c3 : 081;		--	   wait
	02c4 : 081;		--	   wait
	            	--	
	02c5 : 007;		--	   stmwa
	02c6 : 0a7;		--	   ldm b
	02c7 : 009;		--	   stmwd
	02c8 : 081;		--	   wait
	02c9 : 081;		--	   wait
	02ca : 280;		--	   nop nxt
	            	--	
	            	--	getfield_long:
	            	--	    // int off = readOpd16u();
	            	--	    // int ref = stack[sp];
	            	--	    // if (useHandle) {
	            	--	    //	// handle needs indirection
	            	--	    //	ref = readMem(ref);
	            	--	    // }
	            	--	    // stack[sp] = readMem(ref+off);
	            	--	    // stack[++sp] = readMem(ref+off+1);
	            	--	
	02cb : 0f8;		--	   dup // null pointer check
	02cc : 080;		--	   nop // could be interleaved with
	02cd : 04f;		--	   bz null_pointer // following code
	02ce : 080;		--	   nop
	02cf : 080;		--	   nop
	            	--	
	02d0 : 008;		--	   stmra // read handle indirection
	02d1 : 081;		--	   wait // for the GC
	02d2 : 081;		--	   wait
	02d3 : 0e0;		--	   ldmrd
	            	--	
	02d4 : 180;		--	   nop opd
	02d5 : 180;		--	   nop opd
	02d6 : 0f6;		--	   ld_opd_16u // CP index is the offset for the field
	02d7 : 004;		--	   add // +objectref
	            	--	
	02d8 : 0f8;		--	   dup
	            	--	
	02d9 : 008;		--	   stmra
	02da : 0c4;		--	   ldi 1
	02db : 004;		--	   add
	02dc : 026;		--	   stm a
	02dd : 081;		--	   wait
	02de : 081;		--	   wait
	02df : 0e0;		--	   ldmrd // read high word
	            	--	
	02e0 : 0a6;		--	   ldm a
	02e1 : 008;		--	   stmra
	02e2 : 081;		--	   wait
	02e3 : 081;		--	   wait
	02e4 : 2e0;		--	   ldmrd nxt // read low word
	            	--	
	            	--	
	            	--	putfield_long:
	            	--	    // int off = readOpd16u();
	            	--	    // int val_l = stack[sp--];
	            	--	    // int val_h = stack[sp--];
	            	--	    // int ref = stack[sp--];
	            	--	    // if (useHandle) {
	            	--	    // 	// handle needs indirection
	            	--	    // 	ref = readMem(ref);
	            	--	    // }
	            	--	    // writeMem(ref+off, val_h);
	            	--	    // writeMem(ref+off+1, val_l);
	            	--	
	02e5 : 027;		--	   stm b // save low word
	02e6 : 026;		--	   stm a // save high word
	            	--	
	02e7 : 0f8;		--	   dup // null pointer check
	02e8 : 080;		--	   nop // could be interleaved with
	02e9 : 050;		--	   bz null_pointer // following code
	02ea : 080;		--	   nop
	02eb : 080;		--	   nop
	            	--	
	02ec : 008;		--	   stmra // read handle indirection
	02ed : 081;		--	   wait // for the GC
	02ee : 081;		--	   wait
	02ef : 0e0;		--	   ldmrd
	            	--	
	02f0 : 180;		--	   nop opd
	02f1 : 180;		--	   nop opd
	02f2 : 0f6;		--	   ld_opd_16u // CP index is the offset for the field
	02f3 : 004;		--	   add // +objectref
	            	--	
	02f4 : 0f8;		--	   dup
	            	--	
	02f5 : 007;		--	   stmwa // write ext. mem address
	02f6 : 0a6;		--	   ldm a // restore value
	02f7 : 009;		--	   stmwd // write ext. mem data
	02f8 : 0c4;		--	   ldi 1
	02f9 : 004;		--	   add
	02fa : 081;		--	   wait
	02fb : 081;		--	   wait
	            	--	
	02fc : 007;		--	   stmwa
	02fd : 0a7;		--	   ldm b
	02fe : 009;		--	   stmwd
	02ff : 081;		--	   wait
	0300 : 081;		--	   wait
	0301 : 280;		--	   nop nxt
	            	--	
	            	--	lastore:
	0302 : 026;		--	   stm a // value_h
	0303 : 028;		--	   stm c // value_l
	0304 : 027;		--	   stm b // index
	            	--	   // arrayref is TOS
	0305 : 0f8;		--	   dup // for null pointer check
	0306 : 0f8;		--	   dup // for bound check, one cycle wait for bz
	0307 : 051;		--	   bz null_pointer // 
	            	--	   // we do the following in the
	            	--	   // branch slot -> one more element
	            	--	   // from the former dup on the stack
	0308 : 0c4;		--	   ldi 1
	0309 : 004;		--	   add // arrayref+1
	030a : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	030b : 081;		--	   wait // is this ok? - wait in branch slot
	030c : 081;		--	   wait
	030d : 0e0;		--	   ldmrd // read ext. mem (array length)
	            	--	
	030e : 0c4;		--	   ldi 1
	030f : 005;		--	   sub // length-1
	0310 : 0a7;		--	   ldm b // index
	0311 : 005;		--	   sub // TOS = length-1-index
	0312 : 0a7;		--	   ldm b // check if index is negativ
	0313 : 002;		--	   or // is one of both checks neagtv?
	0314 : 0d1;		--	          ldi -2147483648 //  0x80000000
	0315 : 001;		--	   and
	0316 : 080;		--	   nop
	0317 : 072;		--	   bnz array_bound
	0318 : 080;		--	   nop
	0319 : 080;		--	   nop
	            	--	
	031a : 008;		--	   stmra // read handle indirection
	031b : 081;		--	   wait // for the GC
	031c : 081;		--	   wait
	031d : 0e0;		--	   ldmrd
	031e : 0a7;		--	   ldm b
	031f : 0c4;		--	   ldi 1
	0320 : 01d;		--	   shl // index*2
	0321 : 004;		--	   add // index*2+arrayref
	0322 : 029;		--	   stm d
	0323 : 0a9;		--	   ldm d
	0324 : 007;		--	   stmwa // write ext. mem address
	0325 : 0a8;		--	   ldm c
	0326 : 009;		--	   stmwd // write ext. mem data
	0327 : 0a9;		--	   ldm d
	0328 : 0c4;		--	   ldi 1
	0329 : 004;		--	   add // index*2+arrayref+1
	032a : 081;		--	   wait
	032b : 081;		--	   wait
	032c : 007;		--	   stmwa // write ext. mem address
	032d : 0a6;		--	   ldm a
	032e : 009;		--	   stmwd // write ext. mem data
	032f : 081;		--	   wait
	0330 : 081;		--	   wait
	0331 : 280;		--	   nop nxt
	            	--	
	            	--	laload:
	0332 : 027;		--	   stm b // index
	            	--	   // arrayref is TOS
	0333 : 0f8;		--	   dup // for null pointer check
	0334 : 0f8;		--	   dup // for bound check, one cycle wait for bz
	0335 : 053;		--	   bz null_pointer // we do the following in the
	            	--	   // branch slot -> one more element
	            	--	   // from the former dup on the stack
	0336 : 0c4;		--	   ldi 1
	0337 : 004;		--	   add // arrayref+1
	            	--	
	0338 : 008;		--	   stmra // read array length
	0339 : 081;		--	   wait // is this ok? - wait in branch slot
	033a : 081;		--	   wait
	033b : 0e0;		--	   ldmrd // read ext. mem (array length)er	// 
	            	--	
	033c : 0c4;		--	   ldi 1
	033d : 005;		--	   sub // length-1
	033e : 0a7;		--	   ldm b // index
	033f : 005;		--	   sub // TOS = length-1-index
	0340 : 0a7;		--	   ldm b // check if index is negative
	0341 : 002;		--	   or // is one of both checks negative?
	0342 : 0d1;		--	          ldi -2147483648 //  0x80000000
	0343 : 001;		--	   and
	0344 : 080;		--	   nop
	0345 : 074;		--	   bnz array_bound
	0346 : 080;		--	   nop
	0347 : 080;		--	   nop
	            	--	
	0348 : 008;		--	   stmra // read handle indirection
	0349 : 081;		--	   wait // for the GC
	034a : 081;		--	   wait
	034b : 0e0;		--	   ldmrd
	034c : 0a7;		--	   ldm b
	034d : 0c4;		--	   ldi 1
	034e : 01d;		--	   shl // index*2
	034f : 004;		--	   add // index*2+arrayref
	0350 : 0f8;		--	   dup
	0351 : 029;		--	   stm d
	0352 : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	0353 : 081;		--	   wait
	0354 : 081;		--	   wait
	0355 : 0e0;		--	   ldmrd
	0356 : 0a9;		--	   ldm d
	0357 : 0c4;		--	   ldi 1
	0358 : 004;		--	   add // index*2+arrayref+1
	0359 : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	035a : 081;		--	   wait
	035b : 081;		--	   wait
	035c : 2e0;		--	   ldmrd nxt // read ext. mem
	            	--	
	            	--	
	            	--	//
	            	--	//	this is an interrupt, (bytecode 0xf0)
	            	--	//	call com.jopdesign.sys.JVMHelp.interrupt()	(
	            	--	//		oder gleich eine f aus JVMHelp ????
	            	--	//		... JVM in Java!
	            	--	//
	            	--	sys_int:
	035d : 0f2;		--	   ldjpc // correct wrong increment on jpc
	035e : 0c4;		--	   ldi 1 //    could also be done in bcfetch.vhd
	035f : 005;		--	   sub //    but this is simpler :-)
	0360 : 019;		--	   stjpc
	0361 : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	            	--	        // method after methods inherited from Object
	            	--	
	0362 : 0c4;		--	   ldi 1
	0363 : 080;		--	   nop
	0364 : 075;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	0365 : 080;		--	   nop
	0366 : 080;		--	   nop
	            	--	
	            	--	
	            	--	//
	            	--	//	this is an exception, (bytecode 0xf1)
	            	--	//	call com.jopdesign.sys.JVMHelp.except()	(
	            	--	//
	            	--	sys_exc:
	0367 : 0f2;		--	   ldjpc // correct wrong increment on jpc
	0368 : 0c4;		--	   ldi 1 //    could also be done in bcfetch.vhd
	0369 : 005;		--	   sub //    but this is simpler :-)
	036a : 019;		--	   stjpc
	036b : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	036c : 0d2;		--	   ldi 6 // forth method (index 3 * 2 word);
	036d : 004;		--	   add
	            	--	
	            	--	
	036e : 0c4;		--	   ldi 1
	036f : 080;		--	   nop
	0370 : 076;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	0371 : 080;		--	   nop
	0372 : 080;		--	   nop
	            	--	
	            	--	
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx() for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//
	            	--	sys_noim:
	0373 : 0f2;		--	   ldjpc
	0374 : 0c4;		--	   ldi 1
	0375 : 005;		--	   sub
	0376 : 019;		--	   stjpc // get last byte code
	0377 : 080;		--	   nop // ???
	0378 : 080;		--	   nop // one more now (2004-04-06) ?
	0379 : 0a3;		--	   ldm jjp
	037a : 180;		--	   nop opd
	037b : 0f4;		--	   ld_opd_8u
	037c : 0cb;		--	   ldi 255
	037d : 001;		--	   and
	037e : 0f8;		--	   dup
	037f : 004;		--	   add // *2
	0380 : 004;		--	   add // jjp+2*bc
	            	--	
	0381 : 0c4;		--	   ldi 1
	0382 : 080;		--	   nop
	0383 : 077;		--	   bnz invoke // simulate invokestatic with ptr to meth. str. on stack
	0384 : 080;		--	   nop
	0385 : 080;		--	   nop
	            	--	
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx(int constant) for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//		with constant on stack
	            	--	//
	            	--	
	            	--	new:
	            	--	anewarray:
	            	--	checkcast:
	            	--	instanceof:
	            	--	
	            	--	//
	            	--	//	find address for JVM function
	            	--	//
	0386 : 0f2;		--	   ldjpc
	0387 : 0c4;		--	   ldi 1
	0388 : 005;		--	   sub
	0389 : 019;		--	   stjpc // get last byte code
	038a : 080;		--	   nop // ???
	038b : 080;		--	   nop // one more now (2004-04-06) ?
	038c : 0a3;		--	   ldm jjp
	038d : 180;		--	   nop opd
	038e : 0f4;		--	   ld_opd_8u
	038f : 0cb;		--	   ldi 255
	0390 : 001;		--	   and
	0391 : 0f8;		--	   dup
	0392 : 004;		--	   add // *2
	0393 : 004;		--	   add // jjp+2*bc
	0394 : 026;		--	   stm a // save
	            	--	
	            	--	//
	            	--	//	get constant
	            	--	//
	0395 : 1a1;		--	   ldm cp opd
	0396 : 180;		--	   nop opd
	0397 : 0f6;		--	   ld_opd_16u
	0398 : 004;		--	   add
	            	--	
	0399 : 008;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	039a : 081;		--	   wait
	039b : 081;		--	   wait
	039c : 0e0;		--	   ldmrd // read ext. mem
	            	--	
	039d : 0a6;		--	   ldm a // restore mp
	            	--	
	            	--	//
	            	--	//	invoke JVM.fxxx(int cons)
	            	--	//
	039e : 0c4;		--	   ldi 1
	039f : 080;		--	   nop
	03a0 : 078;		--	   bnz invoke
	03a1 : 080;		--	   nop
	03a2 : 080;		--	   nop
	            	--	
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx(int index) for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//		with index into constant pool on stack
	            	--	//
	            	--	
	            	--	putfield_ref:
	            	--	putstatic_ref:
	            	--	
	            	--	//
	            	--	//	find address for JVM function
	            	--	//
	03a3 : 0f2;		--	   ldjpc
	03a4 : 0c4;		--	   ldi 1
	03a5 : 005;		--	   sub
	03a6 : 019;		--	   stjpc // get last byte code
	03a7 : 080;		--	   nop // ???
	03a8 : 080;		--	   nop // one more now (2004-04-06) ?
	03a9 : 0a3;		--	   ldm jjp
	03aa : 180;		--	   nop opd
	03ab : 0f4;		--	   ld_opd_8u
	03ac : 0cb;		--	   ldi 255
	03ad : 001;		--	   and
	03ae : 0f8;		--	   dup
	03af : 004;		--	   add // *2
	03b0 : 004;		--	   add // jjp+2*bc
	03b1 : 026;		--	   stm a // save
	            	--	
	            	--	//
	            	--	//	get index
	            	--	//
	03b2 : 180;		--	   nop opd
	03b3 : 180;		--	   nop opd
	03b4 : 0f6;		--	   ld_opd_16u
	            	--	
	03b5 : 0a6;		--	   ldm a // restore mp
	            	--	
	            	--	//
	            	--	//	invoke JVM.fxxx(int index)
	            	--	//
	03b6 : 0c4;		--	   ldi 1
	03b7 : 080;		--	   nop
	03b8 : 079;		--	   bnz invoke
	03b9 : 080;		--	   nop
	03ba : 080;		--	   nop
	            	--	
	            	--	//****************
	            	--	
	            	--	// special byte codes for native functions
	            	--	
	            	--	//jopsys_rd:
	            	--	//			stioa		// io-address
	            	--	//			nop
	            	--	//			ldiod	nxt	// read data
	            	--	//
	            	--	//jopsys_wr:
	            	--	//			stioa		// io-address
	            	--	//			nop
	            	--	//			stiod	nxt	// write data
	            	--	
	            	--	//
	            	--	//	this sequence takes ram_cnt + 3 cycles
	            	--	//	means ram_cnt-1 wait states (bsy)
	            	--	//	nws = ram_cnt-1
	            	--	//
	            	--	//	or in other words 4+nws
	            	--	//
	            	--	//	For the 100MHz JOP version this sequnce takes
	            	--	//	5 cycles.
	            	--	//
	            	--	//
	            	--	jopsys_rd:
	            	--	jopsys_rdmem:
	03bb : 008;		--	   stmra // read memory, mem_bsy comes one cycle later
	03bc : 081;		--	   wait
	03bd : 081;		--	   wait // execute 1+nws
	03be : 2e0;		--	   ldmrd nxt // read ext. mem
	            	--	
	            	--	
	            	--	//
	            	--	//	The wait states for the write are the same as
	            	--	//	for the read: nws = ram_cnt-1
	            	--	//
	            	--	//	The sequence executes for 5+nws cycles - for the
	            	--	//	100MHz version in 6 cycles
	            	--	//
	            	--	jopsys_wr:
	            	--	jopsys_wrmem:
	03bf : 007;		--	   stmwa // store memory address
	03c0 : 009;		--	   stmwd // store memory data
	03c1 : 081;		--	   wait
	03c2 : 081;		--	   wait // execute 1+nws
	03c3 : 280;		--	   nop nxt
	            	--	
	            	--	jopsys_rdint:
	03c4 : 01a;		--	   star // address in ar
	03c5 : 080;		--	   nop // due to pipelining
	03c6 : 2ed;		--	   ldmi nxt // read value (ar indirect)
	            	--	
	            	--	jopsys_wrint:
	03c7 : 01a;		--	   star // address in ar
	03c8 : 080;		--	   nop // due to pipelining
	03c9 : 215;		--	   stmi nxt // write value (ar indirect)
	            	--	
	            	--	jopsys_getsp:
	03ca : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	03cb : 0c4;		--	   ldi 1 // 'real' sp			da sp auf rd adr zeigt
	03cc : 204;		--	   add nxt
	            	--	jopsys_setsp:
	03cd : 080;		--	   nop // written in adr/read stage!
	03ce : 01b;		--	   stsp // new sp
	03cf : 000;		--	   pop // flash tos, tos-1 (registers)
	03d0 : 200;		--	   pop nxt // sp must be two lower, points to rd adr
	            	--	jopsys_getvp:
	03d1 : 2f1;		--	   ldvp nxt
	            	--	jopsys_setvp:
	03d2 : 018;		--	   stvp
	03d3 : 280;		--	   nop nxt
	            	--	
	            	--	// public static native void int2extMem(int intAdr, int extAdr, int cnt);
	            	--	
	            	--	jopsys_int2ext:
	03d4 : 0c5;		--	   ldi -1
	03d5 : 004;		--	   add
	03d6 : 028;		--	   stm c // counter-1
	03d7 : 008;		--	   stmra // read handle indirection
	03d8 : 027;		--	   stm b // intern address
	03d9 : 081;		--	   wait // for the GC
	03da : 081;		--	   wait
	03db : 0e0;		--	   ldmrd
	03dc : 026;		--	   stm a // extern address
	03dd : 0a8;		--	   ldm c // keep counter on the stack
	            	--	
	            	--	intext_loop:
	03de : 0f8;		--	   dup
	03df : 0a7;		--	   ldm b
	03e0 : 004;		--	   add
	03e1 : 01a;		--	   star
	03e2 : 0f8;		--	   dup
	03e3 : 0a6;		--	   ldm a
	03e4 : 004;		--	   add
	03e5 : 007;		--	   stmwa
	03e6 : 0ed;		--	   ldmi
	03e7 : 009;		--	   stmwd
	03e8 : 0f8;		--	   dup
	03e9 : 081;		--	   wait
	03ea : 081;		--	   wait
	            	--	
	03eb : 07a;		--	   bnz intext_loop
	03ec : 0c5;		--	   ldi -1 // decrement in branch slot
	03ed : 004;		--	   add
	            	--	
	03ee : 200;		--	   pop nxt // remove counter
	            	--	
	            	--	// public static native void ext2intMem(int extAdr, int intAdr, int cnt);
	            	--	
	            	--	jopsys_ext2int:
	03ef : 0c5;		--	   ldi -1
	03f0 : 004;		--	   add
	03f1 : 028;		--	   stm c // counter-1
	03f2 : 027;		--	   stm b // intern address
	03f3 : 008;		--	   stmra // read handle indirection
	03f4 : 081;		--	   wait // for the GC
	03f5 : 081;		--	   wait
	03f6 : 0e0;		--	   ldmrd
	03f7 : 026;		--	   stm a // extern address
	03f8 : 0a8;		--	   ldm c // keep counter on the stack
	            	--	
	            	--	extint_loop:
	03f9 : 0f8;		--	   dup
	03fa : 0a6;		--	   ldm a
	03fb : 004;		--	   add
	03fc : 008;		--	   stmra
	03fd : 0f8;		--	   dup
	03fe : 0a7;		--	   ldm b
	03ff : 004;		--	   add
	0400 : 01a;		--	   star
	0401 : 081;		--	   wait
	0402 : 081;		--	   wait
	0403 : 0e0;		--	   ldmrd // read ext val
	0404 : 015;		--	   stmi
	            	--	
	0405 : 0f8;		--	   dup
	0406 : 080;		--	   nop
	0407 : 07b;		--	   bnz extint_loop
	0408 : 0c5;		--	   ldi -1 // decrement in branch slot
	0409 : 004;		--	   add
	            	--	
	040a : 200;		--	   pop nxt // remove counter
	            	--	
	            	--	//	public static native void memCopy(int src, int dest, int cnt);
	            	--	
	            	--	jopsys_memcpy:
	            	--	// 			ldi	-1
	            	--	// 			add
	            	--	// 			stm c	// counter-1
	            	--	// 			stm b	// destination
	            	--	// 			stm a	// source
	            	--	// 			ldm	c	// keep counter on the stack
	            	--	
	            	--	// memcpy_loop:
	            	--	// 			dup
	            	--	// 			ldm	a
	            	--	// 			add
	            	--	// 			stmra
	            	--	// 			dup
	            	--	// 			ldm	b
	            	--	// 			add
	            	--	// 			stmwa	// should be ok
	            	--	// 			wait
	            	--	// 			wait
	            	--	// 			ldmrd
	            	--	// 			stmwd
	            	--	// 			dup
	            	--	// 			wait
	            	--	// 			wait
	            	--	
	            	--	// 			bnz	memcpy_loop
	            	--	// 			ldi	-1	// decrement in branch slot
	            	--	// 			add
	            	--	
	040b : 00e;		--	   stcp
	040c : 000;		--	   pop
	040d : 081;		--	   wait
	040e : 081;		--	   wait
	040f : 200;		--	   pop nxt
	            	--	
	            	--	
	            	--	
	            	--	//
	            	--	//	some conversions only need a nop!
	            	--	//
	            	--	jopsys_nop:
	0410 : 280;		--	   nop nxt
	            	--	
	            	--	//jopsys_invoke: see invoke
	            	--	
	            	--	
	            	--	//jopsys_cond_move:
	            	--	//			nop		// one cycle for the condition
	            	--	//			bz		false_path
	            	--	//			stm		b
	            	--	//			stm		c
	            	--	//			ldm		c nxt
	            	--	//false_path:	ldm		b nxt

end;
